[
  {
    "objectID": "data_oracles_strategy.html#importing-necessary-libraries-for-analysis",
    "href": "data_oracles_strategy.html#importing-necessary-libraries-for-analysis",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "",
    "text": "Code\nimport yfinance as yf  # For downloading financial data\nimport numpy as np      # For numerical operations\nimport pandas as pd     # For data manipulation\nimport requests # For downloading the API data\nimport numpy as np \nimport plotly.graph_objects as go\nimport plotly.express as px # Import the Plotly Express module for interactive visualization\nimport json\nimport vectorbt as vbt\nfrom plotly.subplots import make_subplots"
  },
  {
    "objectID": "data_oracles_strategy.html#data-collection",
    "href": "data_oracles_strategy.html#data-collection",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "Data Collection",
    "text": "Data Collection\n\nFetch daily OHLCV data\n\n\nCode\n# Data for the TSLA, XLY, and SPY tickers is retrieved from the Yahoo Finance library, covering the period from January 1, 2019, \n# to March 5, 2025.\ntsla = yf.download('TSLA', start='2019-01-01', end='2025-03-05') \nxly = yf.download('XLY', start='2019-01-01', end='2025-03-05')\nspy = yf.download('SPY', start='2019-01-01', end='2025-03-05')\n\n\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\nCode\n# Displays a summary of the TSLA DataFrame, including column names, data types, non-null counts, and memory usage.\ntsla.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 1551 entries, 2019-01-02 to 2025-03-04\nData columns (total 5 columns):\n #   Column          Non-Null Count  Dtype  \n---  ------          --------------  -----  \n 0   (Close, TSLA)   1551 non-null   float64\n 1   (High, TSLA)    1551 non-null   float64\n 2   (Low, TSLA)     1551 non-null   float64\n 3   (Open, TSLA)    1551 non-null   float64\n 4   (Volume, TSLA)  1551 non-null   int64  \ndtypes: float64(4), int64(1)\nmemory usage: 72.7 KB\n\n\n\n\nCode\n# Displays a summary of the XLY DataFrame, including column names, data types, non-null counts, and memory usage.\nxly.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 1551 entries, 2019-01-02 to 2025-03-04\nData columns (total 5 columns):\n #   Column         Non-Null Count  Dtype  \n---  ------         --------------  -----  \n 0   (Close, XLY)   1551 non-null   float64\n 1   (High, XLY)    1551 non-null   float64\n 2   (Low, XLY)     1551 non-null   float64\n 3   (Open, XLY)    1551 non-null   float64\n 4   (Volume, XLY)  1551 non-null   int64  \ndtypes: float64(4), int64(1)\nmemory usage: 72.7 KB\n\n\n\n\nCode\n# Displays a summary of the SPY DataFrame, including column names, data types, non-null counts, and memory usage.\nspy.info()\n\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 1551 entries, 2019-01-02 to 2025-03-04\nData columns (total 5 columns):\n #   Column         Non-Null Count  Dtype  \n---  ------         --------------  -----  \n 0   (Close, SPY)   1551 non-null   float64\n 1   (High, SPY)    1551 non-null   float64\n 2   (Low, SPY)     1551 non-null   float64\n 3   (Open, SPY)    1551 non-null   float64\n 4   (Volume, SPY)  1551 non-null   int64  \ndtypes: float64(4), int64(1)\nmemory usage: 72.7 KB\n\n\n\n\nFetch sentiment scores from the API\n\n\nCode\n# Defines the API endpoint URL for retrieving news sentiment data related to Tesla (TSLA) \n# from the Alpha Vantage service. The query specifies the function type, date range, result limit, \n# targeted ticker symbol, and a valid API key.\n###url = 'https://www.alphavantage.co/query?function=NEWS_SENTIMENT&date_from=20250101T0130&date_to=20250301T0130&limit=1000&tickers=TSLA&apikey=PNM5EHRALIOT1CKJ'\n\n# Sends a GET request to the specified URL to initiate the API call.\n###response = requests.get(url)\n\n# Evaluates whether the API call was successful based on the HTTP response status code.\n###if response.status_code == 200:\n    # Parses the JSON response and extracts the 'feed' section containing sentiment data.\n    ###sentiment_data = response.json()\n    \n    # Converts the extracted sentiment feed into a DataFrame for further analysis or visualization.\n    ###sentiment_df = pd.DataFrame(sentiment_data['feed']) \n    \n    # Displays the first five rows of the sentiment DataFrame to provide an overview of the retrieved content.\n    ###print(sentiment_df.head())\n####else:\n    # Prints an error message if the API request was unsuccessful.\n    ###print(\"API call failed:\", response.status_code)\n\n# Independently parses the full JSON response and prints its contents for inspection or debugging purposes.\n###sentiment_json = response.json()\n###print(sentiment_json)"
  },
  {
    "objectID": "data_oracles_strategy.html#indicator-calculation",
    "href": "data_oracles_strategy.html#indicator-calculation",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "Indicator Calculation",
    "text": "Indicator Calculation\n\nCompute VI+ and VI-\n\n\nCode\n# Defines a function to calculate the Vortex Indicator (VI) for a given DataFrame and ticker symbol.\n# The calculation uses a default lookback period of 14 days unless specified otherwise.\ndef calculate_vortex(df, value, n=14):\n    # Extracts the high, low, and close price series for the specified ticker.\n    high = df[(\"High\", value)]\n    low = df[(\"Low\", value)]\n    close = df[(\"Close\", value)]\n\n    # Calculates the Vortex Movement values:\n    # VM+ = absolute difference between today's high and yesterday's low\n    # VM− = absolute difference between today's low and yesterday's high\n    vm_plus = abs(high - low.shift(1))     # |Today's High – Yesterday’s Low|\n    vm_minus = abs(low - high.shift(1))    # |Today's Low – Yesterday’s High|\n\n    # Computes the True Range (TR) as the maximum of:\n    # - High - Low\n    # - Absolute difference between High and Previous Close\n    # - Absolute difference between Low and Previous Close\n    tr = pd.concat([\n        high - low,\n        abs(high - close.shift(1)),\n        abs(low - close.shift(1))\n    ], axis=1).max(axis=1)\n\n    # Applies a rolling window to compute the n-period sum of VM+ and VM− values\n    # and the corresponding True Range values.\n    sum_vm_plus = vm_plus.rolling(window=n).sum()\n    sum_vm_minus = vm_minus.rolling(window=n).sum()\n    sum_tr = tr.rolling(window=n).sum()\n\n    # Calculates the Vortex Indicator components:\n    # VI+ = sum of VM+ over n periods divided by sum of TR over n periods\n    # VI− = sum of VM− over n periods divided by sum of TR over n periods\n    vi_plus = sum_vm_plus / sum_tr\n    vi_minus = sum_vm_minus / sum_tr\n\n    # Returns the VI+ and VI− series as output.\n    return vi_plus, vi_minus\n\n\n\n\nCode\n# Calculates the Vortex Indicator values for TSLA and stores the results as new columns in the DataFrame.\ntsla['VI+'], tsla['VI-'] = calculate_vortex(tsla, 'TSLA')\n\n# Calculates the Vortex Indicator values for XLY and stores the results as new columns in the DataFrame.\nxly['VI+'], xly['VI-'] = calculate_vortex(xly, 'XLY')\n\n# Calculates the Vortex Indicator values for SPY and stores the results as new columns in the DataFrame.\nspy['VI+'], spy['VI-'] = calculate_vortex(spy, 'SPY')\n\n\n\n\nCode\n# Displays the first 20 rows of the TSLA DataFrame to provide an initial overview of its structure and content with the new function applied.\ntsla.head(20)\n\n\n\n\n\n\n\n\nPrice\nClose\nHigh\nLow\nOpen\nVolume\nVI+\nVI-\n\n\nTicker\nTSLA\nTSLA\nTSLA\nTSLA\nTSLA\n\n\n\n\nDate\n\n\n\n\n\n\n\n\n\n\n\n2019-01-02\n20.674667\n21.008667\n19.920000\n20.406668\n174879000\nNaN\nNaN\n\n\n2019-01-03\n20.024000\n20.626667\n19.825333\n20.466667\n104478000\nNaN\nNaN\n\n\n2019-01-04\n21.179333\n21.200001\n20.181999\n20.400000\n110911500\nNaN\nNaN\n\n\n2019-01-07\n22.330667\n22.449333\n21.183332\n21.448000\n113268000\nNaN\nNaN\n\n\n2019-01-08\n22.356667\n22.934000\n21.801332\n22.797333\n105127500\nNaN\nNaN\n\n\n2019-01-09\n22.568666\n22.900000\n22.098000\n22.366667\n81493500\nNaN\nNaN\n\n\n2019-01-10\n22.997999\n23.025999\n22.119333\n22.293333\n90846000\nNaN\nNaN\n\n\n2019-01-11\n23.150667\n23.227333\n22.584667\n22.806000\n75586500\nNaN\nNaN\n\n\n2019-01-14\n22.293333\n22.833332\n22.266666\n22.825333\n78709500\nNaN\nNaN\n\n\n2019-01-15\n22.962000\n23.253332\n22.299999\n22.333332\n90849000\nNaN\nNaN\n\n\n2019-01-16\n23.070000\n23.466667\n22.900000\n22.985332\n70375500\nNaN\nNaN\n\n\n2019-01-17\n23.153999\n23.433332\n22.943333\n23.080667\n55150500\nNaN\nNaN\n\n\n2019-01-18\n20.150667\n21.808666\n19.982000\n21.533333\n362262000\nNaN\nNaN\n\n\n2019-01-22\n19.927999\n20.533333\n19.700001\n20.321333\n181000500\nNaN\nNaN\n\n\n2019-01-23\n19.172667\n19.633333\n18.779333\n19.500000\n187950000\n0.938520\n0.946160\n\n\n2019-01-24\n19.434000\n19.578667\n18.618668\n18.868668\n120183000\n0.937771\n0.927867\n\n\n2019-01-25\n19.802668\n19.901333\n19.303333\n19.625999\n108744000\n0.969095\n0.953411\n\n\n2019-01-28\n19.758667\n19.830667\n19.183332\n19.527332\n96349500\n0.886399\n1.047633\n\n\n2019-01-29\n19.830667\n19.903999\n19.453333\n19.684668\n69325500\n0.853825\n1.081611\n\n\n2019-01-30\n20.584667\n20.600000\n19.899332\n20.030001\n168754500\n0.859650\n1.020518\n\n\n\n\n\n\n\n\n\nCalculate Volume-Weighted Sentiment\n\n\nCode\n# Load the sentiment JSON file from local storage\nwith open(\"TSLA_sentiment.json\", \"r\") as f:\n    sentiment_json = json.load(f)\n\n# Extract the \"feed\" list from the top-level JSON dictionary.\n# This section contains the array of sentiment articles or entries.\nsentiment_feed = sentiment_json.get(\"feed\", [])\n\n# Initialize an empty list to hold cleaned and structured sentiment data\nsentiment_data = []\n\n# Iterate through each item in the sentiment feed to extract relevant fields\nfor item in sentiment_feed:\n    try:\n        sentiment_data.append({\n            # Convert the timestamp to pandas datetime for proper indexing\n            \"time_published\": pd.to_datetime(item[\"time_published\"]),\n            # Convert the sentiment score string to float\n            \"sentiment_score\": float(item[\"overall_sentiment_score\"]),\n            # Store the sentiment label (e.g., Positive, Neutral, Negative)\n            \"sentiment_label\": item[\"overall_sentiment_label\"],\n        })\n    except (KeyError, ValueError, TypeError):\n        # Skip malformed or incomplete entries that raise an error\n        continue\n\n# Convert the structured list of dictionaries into a pandas DataFrame\nsentiment_df = pd.DataFrame(sentiment_data)\n\n# Set the 'time_published' column as the DataFrame index to enable time-series operations\nsentiment_df.set_index(\"time_published\", inplace=True)\n\n# Display the first few rows of the DataFrame to verify content and structure\nprint(sentiment_df.head())\n\n# Output a summary of the DataFrame structure, including column types and memory usage\nprint(sentiment_df.info())\n\n\n                     sentiment_score   sentiment_label\ntime_published                                        \n2025-03-01 00:00:18         0.225994  Somewhat-Bullish\n2025-02-28 20:33:00        -0.098739           Neutral\n2025-02-28 20:07:43        -0.041235           Neutral\n2025-02-28 20:07:36        -0.038786           Neutral\n2025-02-28 18:24:25         0.021961           Neutral\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 681 entries, 2025-03-01 00:00:18 to 2025-01-31 13:58:04\nData columns (total 2 columns):\n #   Column           Non-Null Count  Dtype  \n---  ------           --------------  -----  \n 0   sentiment_score  681 non-null    float64\n 1   sentiment_label  681 non-null    object \ndtypes: float64(1), object(1)\nmemory usage: 16.0+ KB\nNone\n\n\n\n\nCode\n# Initialize an empty list to store processed sentiment records\nsentiment_data = []\n\n# Iterate through each news item in the 'feed' section of the JSON object\nfor news_item in sentiment_json.get(\"feed\", []):\n    # Append a dictionary with selected and transformed fields to the sentiment list\n    sentiment_data.append({\n        # Convert the time of publication to datetime format\n        \"time_published\": pd.to_datetime(news_item[\"time_published\"]),\n        # Extract the sentiment score (as-is; conversion to float may be handled separately if needed)\n        \"sentiment_score\": news_item[\"overall_sentiment_score\"],\n        # Extract the sentiment label (e.g., Positive, Neutral, Negative)\n        \"sentiment_label\": news_item[\"overall_sentiment_label\"],\n    })\n\n# Convert the list of dictionaries into a pandas DataFrame\nsentiment_data = pd.DataFrame(sentiment_data)\n\n\n\n\nCode\n# Sort the DataFrame by publication time in ascending order for chronological analysis\nsentiment_data['time_published'].sort_values(ascending=True)\n\n\n680   2025-01-31 13:58:04\n679   2025-01-31 14:05:00\n678   2025-01-31 14:05:31\n677   2025-01-31 14:31:00\n676   2025-01-31 15:13:26\n              ...        \n4     2025-02-28 18:24:25\n3     2025-02-28 20:07:36\n2     2025-02-28 20:07:43\n1     2025-02-28 20:33:00\n0     2025-03-01 00:00:18\nName: time_published, Length: 681, dtype: datetime64[ns]\n\n\n\n\nCode\n# Convert the 'time_published' column to only retain the date portion (drop time-of-day)\nsentiment_data['time_published'] = sentiment_data['time_published'].dt.date\n\n\n\n\nCode\n# Filter sentiment data to retain only those records that match dates present in the TSLA index\nsentiment_scores_filtered = sentiment_data[\n    pd.to_datetime(sentiment_data['time_published']).isin(tsla.index)\n]\n\n# Group the filtered data by publication date and calculate the average sentiment score per day\nsentiment_scores_filtered = sentiment_scores_filtered.groupby('time_published')['sentiment_score'].mean().reset_index()\n\n\n\n\nCode\n# Fix the multi-level column issue by selecting the 'Volume' column and resetting its name\ntsla_volume = tsla[('Volume', 'TSLA')].rename('Volume')\n\n# Ensure the index of tsla_volume is a column and convert it to match the type of time_published\ntsla_volume = tsla_volume.reset_index()\ntsla_volume['Date'] = pd.to_datetime(tsla_volume['Date'])\n\n\n\n\nCode\n# Convert 'time_published' in the sentiment data to datetime to match volume data type\nsentiment_scores_filtered['time_published'] = pd.to_datetime(sentiment_scores_filtered['time_published'])\n\n# Perform an inner merge between sentiment scores and volume data based on matching dates\nmerged_data = pd.merge(\n    tsla_volume,\n    sentiment_scores_filtered,\n    left_on='Date',\n    right_on='time_published',\n    how='inner'\n)\n\n\n\n\nCode\n# Compute the weighted sentiment by multiplying raw sentiment by trading volume\nmerged_data['Weighted_Sentiment'] = merged_data['Volume'] * merged_data['sentiment_score']\n\n# Calculate a 5-day rolling average of the weighted sentiment to smooth short-term noise\nmerged_data['5_day_avg_sentiment'] = merged_data['Weighted_Sentiment'].rolling(window=5).mean()\n\n# Define a binary condition for when the average sentiment is positive\nmerged_data['Buy_Condition'] = merged_data['5_day_avg_sentiment'] &gt; 0\n\n# Normalize the rolling sentiment score by average volume to allow comparability across scales\nmerged_data['5_day_avg_sentiment_norm'] = (\n    merged_data['5_day_avg_sentiment'] / merged_data['Volume'].mean()\n)\n\n\n\n\nCode\nmerged_data\n\n\n\n\n\n\n\n\n\nDate\nVolume\ntime_published\nsentiment_score\nWeighted_Sentiment\n5_day_avg_sentiment\nBuy_Condition\n5_day_avg_sentiment_norm\n\n\n\n\n0\n2025-01-31\n83568200\n2025-01-31\n0.194614\n1.626354e+07\nNaN\nFalse\nNaN\n\n\n1\n2025-02-03\n93732100\n2025-02-03\n0.129243\n1.211426e+07\nNaN\nFalse\nNaN\n\n\n2\n2025-02-04\n57072200\n2025-02-04\n0.173107\n9.879602e+06\nNaN\nFalse\nNaN\n\n\n3\n2025-02-05\n57223300\n2025-02-05\n0.136874\n7.832396e+06\nNaN\nFalse\nNaN\n\n\n4\n2025-02-06\n77918200\n2025-02-06\n0.118095\n9.201782e+06\n1.105832e+07\nTrue\n0.132787\n\n\n5\n2025-02-07\n70298300\n2025-02-07\n0.133871\n9.410915e+06\n9.687792e+06\nTrue\n0.116330\n\n\n6\n2025-02-10\n77514900\n2025-02-10\n0.152754\n1.184073e+07\n9.633086e+06\nTrue\n0.115673\n\n\n7\n2025-02-11\n118543400\n2025-02-11\n0.164455\n1.949505e+07\n1.155618e+07\nTrue\n0.138766\n\n\n8\n2025-02-12\n105382700\n2025-02-12\n0.147806\n1.557620e+07\n1.310494e+07\nTrue\n0.157363\n\n\n9\n2025-02-13\n89441500\n2025-02-13\n0.157124\n1.405337e+07\n1.407525e+07\nTrue\n0.169015\n\n\n10\n2025-02-14\n68277300\n2025-02-14\n0.148619\n1.014733e+07\n1.422254e+07\nTrue\n0.170783\n\n\n11\n2025-02-18\n51631700\n2025-02-18\n0.147289\n7.604774e+06\n1.337534e+07\nTrue\n0.160610\n\n\n12\n2025-02-19\n67094400\n2025-02-19\n0.142078\n9.532654e+06\n1.138286e+07\nTrue\n0.136685\n\n\n13\n2025-02-20\n45965400\n2025-02-20\n0.168076\n7.725658e+06\n9.812757e+06\nTrue\n0.117831\n\n\n14\n2025-02-21\n74058600\n2025-02-21\n0.159107\n1.178322e+07\n9.358728e+06\nTrue\n0.112379\n\n\n15\n2025-02-24\n76052300\n2025-02-24\n0.110839\n8.429546e+06\n9.015171e+06\nTrue\n0.108253\n\n\n16\n2025-02-25\n134228800\n2025-02-25\n0.071949\n9.657658e+06\n9.425748e+06\nTrue\n0.113184\n\n\n17\n2025-02-26\n100118300\n2025-02-26\n0.142984\n1.431534e+07\n1.038228e+07\nTrue\n0.124670\n\n\n18\n2025-02-27\n101748200\n2025-02-27\n0.174702\n1.777563e+07\n1.239228e+07\nTrue\n0.148806\n\n\n19\n2025-02-28\n115697000\n2025-02-28\n0.115746\n1.339148e+07\n1.271393e+07\nTrue\n0.152668\n\n\n\n\n\n\n\n\n\nDerive ATR (10) for Volatility Adjustments\n\n\nCode\n# Flatten MultiIndex columns if present to simplify DataFrame operations\ntsla.columns = [\n    '_'.join(col).strip() if isinstance(col, tuple) else col\n    for col in tsla.columns\n]\n\n# Calculate the previous closing price to support True Range computation\ntsla[\"prev_close\"] = tsla[\"Close_TSLA\"].shift(1)\n\n# Compute three True Range variations used in ATR calculation\ntsla[\"tr1\"] = tsla[\"High_TSLA\"] - tsla[\"Low_TSLA\"]\ntsla[\"tr2\"] = abs(tsla[\"High_TSLA\"] - tsla[\"prev_close\"])\ntsla[\"tr3\"] = abs(tsla[\"Low_TSLA\"] - tsla[\"prev_close\"])\n\n# Derive the True Range (TR) as the maximum of the three variants\ntsla[\"true_range\"] = tsla[[\"tr1\", \"tr2\", \"tr3\"]].max(axis=1)\n\n# Compute the 10-day Average True Range (ATR) to measure market volatility\ntsla[\"ATR_10\"] = tsla[\"true_range\"].rolling(window=10).mean()\n\n# Calculate ATR as a percentage of the current closing price to normalize volatility\ntsla[\"atr_pct\"] = tsla[\"ATR_10\"] / tsla[\"Close_TSLA\"]\n\n# Define a function to assign position size based on volatility levels\ndef position_size(row):\n    if row[\"atr_pct\"] &lt; 0.03:\n        return 0.01  # Allocate 1% of capital for low-volatility conditions\n    else:\n        return 0.005  # Allocate 0.5% of capital for high-volatility conditions\n\n# Apply the position size function across all rows\ntsla[\"position_size\"] = tsla.apply(position_size, axis=1)\n\n# Display the latest 10 rows with selected indicators for inspection\nprint(tsla[[\"Close_TSLA\", \"ATR_10\", \"atr_pct\", \"position_size\"]].tail(10))\n\n\n            Close_TSLA     ATR_10   atr_pct  position_size\nDate                                                      \n2025-02-19  360.559998  16.703000  0.046325          0.005\n2025-02-20  354.399994  16.464999  0.046459          0.005\n2025-02-21  337.799988  17.021997  0.050391          0.005\n2025-02-24  330.529999  16.770996  0.050740          0.005\n2025-02-25  302.799988  18.879996  0.062351          0.005\n2025-02-26  290.799988  18.412994  0.063318          0.005\n2025-02-27  281.950012  18.257996  0.064756          0.005\n2025-02-28  292.980011  18.067996  0.061670          0.005\n2025-03-03  284.649994  19.281998  0.067739          0.005\n2025-03-04  272.040009  20.654996  0.075926          0.005\n\n\n\n\nCode\n# Create a line chart to visualize the ATR% (Average True Range as a percentage of price) over time\nfig = px.line(\n    tsla, \n    x=tsla.index, \n    y=\"atr_pct\", \n    title=\"ATR% Over Time\"  # Title of the chart\n)\n\n# Add a horizontal reference line at 3% to represent the low-volatility cutoff threshold\nfig.add_hline(\n    y=0.03, \n    line_dash=\"dot\", \n    line_color=\"green\", \n    annotation_text=\"Low Volatility Cutoff\"\n)\n\n# Display the chart\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nThe chart illustrates the historical volatility of TSLA, measured by the Average True Range (ATR) as a percentage of the closing price. Periods where the ATR% falls below the dotted green line at 3% indicate low volatility, which is typically associated with more stable market conditions. In contrast, noticeable spikes—such as those seen in 2020 and 2021—reflect periods of heightened volatility. More recently, ATR% values appear to remain closer to or slightly above the low-volatility threshold, suggesting relatively calmer market behavior compared to earlier years.\n\n\nCode\n# Filter the TSLA DataFrame to include only records from the year 2025\ntsla_2025 = tsla[tsla.index.year == 2025]\n\n# Create a line chart to visualize ATR% for TSLA during 2025\nfig = px.line(\n    tsla_2025,\n    x=tsla_2025.index,\n    y=\"atr_pct\",\n    title=\"ATR% Over Time (2025 Only)\"\n)\n\n# Add a horizontal line at the 3% threshold to denote the low-volatility cutoff\nfig.add_hline(\n    y=0.03,\n    line_dash=\"dot\",\n    line_color=\"green\",\n    annotation_text=\"Low Volatility Cutoff\"\n)\n\n# Display the chart\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nThe chart displays ATR% for TSLA during 2025, reflecting how the stock’s volatility has evolved since the start of the year. While ATR% began above the 7% mark in early January, it gradually declined and remained mostly between 4% and 6% throughout February. Although volatility did not breach the low-volatility threshold of 3%, the dip toward that level suggests a period of relative calm. Toward early March, ATR% showed a clear upward trend, indicating a potential resurgence in market volatility.\n\n\nCode\n# Create Buy Signal\ntsla['Buy_Signal'] = tsla['VI+_'] &gt; tsla['VI-_']  # Vortex crossover\n\n# Create Sell Signal (basic)\ntsla['Sell_Signal'] = tsla['VI-_'] &gt; tsla['VI+_']\n\n# Initialize the position tracking column with 0 (no active position)\ntsla['Position'] = 0\n\n# Initialize a variable to store the peak price during a position for trailing stop logic\npeak_price = 0\n\n# Iterate through the dataset starting from index 1 to access previous values\nfor i in range(1, len(tsla)):\n\n    # Entry condition: enter a position if a buy signal is present\n    if tsla['Buy_Signal'].iloc[i]:\n        tsla.at[tsla.index[i], 'Position'] = 1  # Mark entry into a position\n        peak_price = tsla['Close_TSLA'].iloc[i]  # Record the entry price as initial peak\n\n    # If already in position, check for exit condition using trailing stop\n    elif tsla['Position'].iloc[i - 1] == 1:\n        current_price = tsla['Close_TSLA'].iloc[i]  # Current closing price\n        peak_price = max(peak_price, current_price)  # Update peak price if current exceeds previous\n        drawdown = (peak_price - current_price) / peak_price  # Compute drawdown from peak\n\n        # Exit condition: drawdown exceeds 3%\n        if drawdown &gt;= 0.03:\n            tsla.at[tsla.index[i], 'Sell_Signal'] = True  # Trigger a sell signal\n            tsla.at[tsla.index[i], 'Position'] = 0        # Exit position\n        else:\n            tsla.at[tsla.index[i], 'Position'] = 1        # Maintain position\n\n# Display the total number of buy and sell signals generated across the dataset\nprint(\"Buy signals:\", tsla['Buy_Signal'].sum())\nprint(\"Sell signals:\", tsla['Sell_Signal'].sum())\n\n\nBuy signals: 857\nSell signals: 680\n\n\n\n\nCode\n# Create an empty figure object\nfig = go.Figure()\n\n# Plot the TSLA closing price as a continuous line\nfig.add_trace(go.Scatter(\n    x=tsla.index,\n    y=tsla['Close_TSLA'],\n    mode='lines',\n    name='TSLA Price'\n))\n\n# Add markers to indicate Buy Signals using upward-pointing green triangles\nfig.add_trace(go.Scatter(\n    x=tsla[tsla['Buy_Signal']].index,\n    y=tsla[tsla['Buy_Signal']]['Close_TSLA'],\n    mode='markers',\n    marker=dict(symbol='triangle-up', size=10, color='green'),\n    name='Buy Signal'\n))\n\n# Add markers to indicate Sell Signals using downward-pointing red triangles\nfig.add_trace(go.Scatter(\n    x=tsla[tsla['Sell_Signal']].index,\n    y=tsla[tsla['Sell_Signal']]['Close_TSLA'],\n    mode='markers',\n    marker=dict(symbol='triangle-down', size=10, color='red'),\n    name='Sell Signal'\n))\n\n# Update layout settings including title and visual style\nfig.update_layout(\n    title='TSLA Buy & Sell Signals',\n    template='plotly_white'\n)\n\n# Render the interactive plot\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nThe chart illustrates the closing price of Tesla stock over time, with overlaid trading signals generated by the strategy. Green upward triangles represent buy signals, while red downward triangles mark sell signals. These signals are distributed throughout periods of both rising and falling prices, reflecting how the algorithm dynamically enters and exits positions based on market conditions. Clusters of signals during high-volatility periods—such as 2020, 2021, and early 2025—indicate frequent entries and exits, whereas more stable phases show fewer trades.\n\n\nCode\n# Calculate ATR as a percentage of the closing price to normalize volatility\ntsla['atr_pct'] = tsla['ATR_10'] / tsla['Close_TSLA']\n\n# Define Vortex Indicator crossover signals:\n# - VI_Cross_Up: Identifies when VI+ crosses above VI− (potential bullish signal)\n# - VI_Cross_Down: Identifies when VI− crosses above VI+ (potential bearish signal)\ntsla['VI_Cross_Up'] = (tsla['VI+_'] &gt; tsla['VI-_']) & (tsla['VI+_'].shift(1) &lt;= tsla['VI-_'].shift(1))\ntsla['VI_Cross_Down'] = (tsla['VI-_'] &gt; tsla['VI+_']) & (tsla['VI-_'].shift(1) &lt;= tsla['VI+_'].shift(1))\n\n# Initialize signal and state columns\ntsla['Buy_Signal'] = False          # Flag for buy signal\ntsla['Sell_Signal'] = False         # Flag for sell signal\ntsla['Position'] = 0                # Position state: 1 = in position, 0 = no position\ntsla['Entry_Type'] = None           # Strategy classification: 'aggressive' or 'conservative'\n\n# Initialize control variables for trailing stop and price tracking\nin_position = False                 # Boolean flag for current position state\npeak_price = 0                      # Highest price observed during an open position\n\n# Iterate through the DataFrame to simulate trading logic based on Vortex signals and volatility\nfor i in range(1, len(tsla)):\n    row = tsla.iloc[i]\n    idx = tsla.index[i]\n\n    # Buy condition: Enter a new position if VI_Cross_Up occurs and no current position is held\n    if not in_position and row['VI_Cross_Up']:\n        tsla.at[idx, 'Buy_Signal'] = True\n        tsla.at[idx, 'Position'] = 1\n        in_position = True\n        peak_price = row['Close_TSLA']\n\n        # Classify entry type based on volatility threshold\n        if row['atr_pct'] &lt; 0.03:\n            tsla.at[idx, 'Entry_Type'] = 'aggressive'\n        else:\n            tsla.at[idx, 'Entry_Type'] = 'conservative'\n\n    # While in position, evaluate for trailing stop or VI_Cross_Down exit condition\n    elif in_position:\n        current_price = row['Close_TSLA']\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        # Sell condition: Exit if drawdown exceeds 3% or VI_Cross_Down occurs\n        if drawdown &gt;= 0.03 or row['VI_Cross_Down']:\n            tsla.at[idx, 'Sell_Signal'] = True\n            tsla.at[idx, 'Position'] = 0\n            in_position = False\n        else:\n            tsla.at[idx, 'Position'] = 1  # Maintain position\n\n# Output the total count of each type of signal and entry classification\nprint(\"Buy signals:\", tsla['Buy_Signal'].sum())\nprint(\"Sell signals:\", tsla['Sell_Signal'].sum())\nprint(\"Aggressive entries:\", (tsla['Entry_Type'] == 'aggressive').sum())\nprint(\"Conservative entries:\", (tsla['Entry_Type'] == 'conservative').sum())\n\n\nBuy signals: 80\nSell signals: 80\nAggressive entries: 5\nConservative entries: 75\n\n\n\n\nCode\n# Create an empty figure to hold all plot layers\nfig = go.Figure()\n\n# Plot the TSLA closing price as a continuous blue line\nfig.add_trace(go.Scatter(\n    x=tsla.index,\n    y=tsla['Close_TSLA'],\n    mode='lines',\n    name='TSLA Price',\n    line=dict(color='blue')\n))\n\n# Add markers for aggressive buy signals (Entry_Type = 'aggressive')\nfig.add_trace(go.Scatter(\n    x=tsla[(tsla['Buy_Signal']) & (tsla['Entry_Type'] == 'aggressive')].index,\n    y=tsla[(tsla['Buy_Signal']) & (tsla['Entry_Type'] == 'aggressive')]['Close_TSLA'],\n    mode='markers',\n    name='Buy (Aggressive)',\n    marker=dict(symbol='triangle-up', color='limegreen', size=10)\n))\n\n# Add markers for conservative buy signals (Entry_Type = 'conservative')\nfig.add_trace(go.Scatter(\n    x=tsla[(tsla['Buy_Signal']) & (tsla['Entry_Type'] == 'conservative')].index,\n    y=tsla[(tsla['Buy_Signal']) & (tsla['Entry_Type'] == 'conservative')]['Close_TSLA'],\n    mode='markers',\n    name='Buy (Conservative)',\n    marker=dict(symbol='triangle-up', color='green', size=10)\n))\n\n# Add markers for sell signals using red downward-pointing triangles\nfig.add_trace(go.Scatter(\n    x=tsla[tsla['Sell_Signal']].index,\n    y=tsla[tsla['Sell_Signal']]['Close_TSLA'],\n    mode='markers',\n    name='Sell Signal',\n    marker=dict(symbol='triangle-down', color='red', size=10)\n))\n\n# Configure chart layout with appropriate title, axis labels, and style\nfig.update_layout(\n    title='TSLA Buy/Sell Signals Over Time',\n    xaxis_title='Date',\n    yaxis_title='Price (USD)',\n    template='plotly_white',\n    height=600\n)\n\n# Render the figure\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nThe chart displays the historical closing price of Tesla (TSLA) stock alongside algorithmically generated buy and sell signals. The blue line represents TSLA’s closing price, while the green upward-pointing triangles indicate buy entries—distinguished by lime green for aggressive entries (lower volatility) and dark green for conservative entries (higher volatility). Red downward-pointing triangles represent sell signals.\nThe buy signals are generally aligned with upward momentum, and sell signals frequently follow periods of short-term retracement or heightened volatility. The system shows particularly dense activity around highly volatile phases, such as mid-2020 to early 2022, capturing many entries and exits. In contrast, during more stable periods, the signals are more spaced out. Overall, the plot provides a clear visual assessment of how the strategy adapts dynamically to changing market conditions by modulating its entries based on volatility and exiting with protective trailing logic."
  },
  {
    "objectID": "data_oracles_strategy.html#tesla-analysis-results",
    "href": "data_oracles_strategy.html#tesla-analysis-results",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "Tesla Analysis Results",
    "text": "Tesla Analysis Results\n\n\nCode\ntsla_signals = tsla.reset_index()[['Date', 'VI_Cross_Up', 'VI_Cross_Down', 'atr_pct', 'Close_TSLA']]\n\n\n\n\nCode\nmerged_data = pd.merge(merged_data, tsla, on='Date', how='left')\n\n\n\n\nCode\n# Calculate ATR percentage\nmerged_data['atr_pct'] = merged_data['ATR_10'] / merged_data['Close_TSLA']\n\n# Vortex crossover logic\nmerged_data['VI_Cross_Up'] = (merged_data['VI+_'] &gt; merged_data['VI-_']) & (merged_data['VI+_'].shift(1) &lt;= merged_data['VI-_'].shift(1))\nmerged_data['VI_Cross_Down'] = (merged_data['VI-_'] &gt; merged_data['VI+_']) & (merged_data['VI-_'].shift(1) &lt;= merged_data['VI+_'].shift(1))\n\n# Initialize signal & state columns\nmerged_data['Buy_Signal'] = False\nmerged_data['Sell_Signal'] = False\nmerged_data['Position'] = 0\nmerged_data['Entry_Type'] = None  # aggressive/conservative\n\n# Trailing stop logic variables\nin_position = False\npeak_price = 0\n\nfor i in range(1, len(merged_data)):\n    row = merged_data.iloc[i]\n    idx = merged_data.index[i]\n    # Buy condition\n    if not in_position or row['VI_Cross_Up'] or row['5_day_avg_sentiment_norm']&gt;0:\n        merged_data.at[idx, 'Buy_Signal'] = True\n        merged_data.at[idx, 'Position'] = 1\n        in_position = True\n        peak_price = row['Close_TSLA']\n\n        # Entry Type: aggressive if ATR &lt; 3%, else conservative\n        if row['atr_pct'] &lt; 0.03:\n            merged_data.at[idx, 'Entry_Type'] = 'aggressive'\n        else:\n            merged_data.at[idx, 'Entry_Type'] = 'conservative'\n\n    # While in position, check for trailing stop or VI cross down\n    elif in_position:\n        current_price = row['Close_TSLA']\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03 or row['VI_Cross_Down']:\n            merged_data.at[idx, 'Sell_Signal'] = True\n            merged_data.at[idx, 'Position'] = 0\n            in_position = False\n        else:\n            merged_data.at[idx, 'Position'] = 1\n\n# Show result counts\nprint(\"Buy signals:\", merged_data['Buy_Signal'].sum())\nprint(\"Sell signals:\", merged_data['Sell_Signal'].sum())\nprint(\"Aggressive entries:\", (merged_data['Entry_Type'] == 'aggressive').sum())\nprint(\"Conservative entries:\", (merged_data['Entry_Type'] == 'conservative').sum())\n\n\nBuy signals: 18\nSell signals: 1\nAggressive entries: 0\nConservative entries: 18\n\n\n\n\nCode\n# Ensure 'Date' is datetime and set as index if needed\nmerged_data['Date'] = pd.to_datetime(merged_data['Date'])\n\nfig = go.Figure()\n\n# Plot 5-day Avg Sentiment\nfig.add_trace(go.Scatter(\n    x=merged_data['Date'],\n    y=merged_data['5_day_avg_sentiment_norm'],\n    mode='lines+markers',\n    name='5-Day Avg Sentiment',\n    line=dict(color='blue')\n))\n\n# Plot ATR %\nfig.add_trace(go.Scatter(\n    x=merged_data['Date'],\n    y=merged_data['atr_pct'],\n    mode='lines+markers',\n    name='ATR %',\n    yaxis='y2',\n    line=dict(color='orange')\n))\n\n# Optional: Highlight Buy Signal Dates (even though there are none now)\nfig.add_trace(go.Scatter(\n    x=merged_data.loc[merged_data['Buy_Signal'], 'Date'],\n    y=merged_data.loc[merged_data['Buy_Signal'], '5_day_avg_sentiment_norm'],\n    mode='markers',\n    marker=dict(color='green', size=10, symbol='star'),\n    name='Buy Signal'\n))\n\n# Add dual axis layout\nfig.update_layout(\n    title=\"5-Day Sentiment vs ATR % (with Buy Signals)\",\n    xaxis_title='Date',\n    yaxis=dict(title='5-Day Avg Sentiment'),\n    yaxis2=dict(title='ATR %', overlaying='y', side='right'),\n    legend=dict(x=0.01, y=0.99),\n    height=500\n)\n\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Initialize portfolio variables\ncapital = 100000                   # Starting capital for the simulation\nin_position = False               # Flag indicating whether a position is currently held\nentry_price = 0                   # Entry price of the current position\nposition_value = 0                # Dollar value allocated to the position\ncash = capital                    # Available cash (initially equal to capital)\nreturns = []                      # List to store profit/loss for each trade\n\n# Iterate over the dataset to simulate trading\nfor i in range(len(merged_data)):\n    row = merged_data.iloc[i]\n\n    # ==== Buy Logic ====\n    if row['Buy_Signal'] and not in_position:\n        position_size = row['position_size']             # Fraction of capital to allocate\n        position_value = cash * position_size            # Calculate how much capital to invest\n        entry_price = row['Close_TSLA']                  # Record entry price\n        shares_bought = position_value / entry_price     # Calculate number of shares to buy\n        cash -= position_value                           # Deduct invested capital from cash\n        in_position = True                               # Update position flag\n\n    # ==== Sell Logic ====\n    elif row['Sell_Signal'] and in_position:\n        exit_price = row['Close_TSLA']                   # Get the exit price\n        proceeds = shares_bought * exit_price            # Calculate proceeds from sale\n        profit = proceeds - position_value               # Profit = proceeds - initial investment\n        cash += proceeds                                 # Add proceeds back to cash\n        returns.append(profit)                           # Record trade return\n        in_position = False                              # Reset position state\n        position_value = 0                               # Clear position value\n        entry_price = 0                                  # Reset entry price\n\n# ==== Final Capital Calculation ====\n# If still holding a position, add unrealized value to cash\nfinal_value = cash + (shares_bought * row['Close_TSLA'] if in_position else 0)\ntotal_return = final_value - capital                    # Net profit/loss from strategy\n\n# ==== Print Performance Metrics ====\nprint(f\"Final Capital: ${final_value:,.2f}\")\nprint(f\"Total Return: ${total_return:.2f}\")\nprint(f\"Total Trades: {len(returns)}\")\nprint(f\"Average Profit per Trade: ${np.mean(returns):.2f}\")\n\n\nFinal Capital: $99,898.47\nTotal Return: $-101.53\nTotal Trades: 1\nAverage Profit per Trade: $11.12\n\n\n\n\nCode\n# Make sure index is datetime and 'Close_TSLA' exists\nprice = tsla['Close_TSLA']\n\n# Generate entries and exits from your signals\nentries = tsla['Buy_Signal']\nexits = tsla['Sell_Signal']\n\n# Create portfolio\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    size=np.nan,  # Let it auto-calculate position size if fixed capital\n    init_cash=100_000,\n    fees=0.001,  # 0.1% per trade\n    slippage=0.0005  # Optional\n)\n\n\n\n\nCode\n# Summary stats\nprint(portfolio.stats())\n\n# Equity curve\nportfolio.plot().show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nStart                         2019-01-02 00:00:00\nEnd                           2025-03-04 00:00:00\nPeriod                                       1551\nStart Value                              100000.0\nEnd Value                                100000.0\nTotal Return [%]                              0.0\nBenchmark Return [%]                  1215.813231\nMax Gross Exposure [%]                        0.0\nTotal Fees Paid                               0.0\nMax Drawdown [%]                              NaN\nMax Drawdown Duration                         NaN\nTotal Trades                                    0\nTotal Closed Trades                             0\nTotal Open Trades                               0\nOpen Trade PnL                                0.0\nWin Rate [%]                                  NaN\nBest Trade [%]                                NaN\nWorst Trade [%]                               NaN\nAvg Winning Trade [%]                         NaN\nAvg Losing Trade [%]                          NaN\nAvg Winning Trade Duration                    NaN\nAvg Losing Trade Duration                     NaN\nProfit Factor                                 NaN\nExpectancy                                    NaN\ndtype: object\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nprint(tsla['Buy_Signal'].sum())  # Should be &gt; 0\nprint(tsla['Sell_Signal'].sum())  # Should also be &gt; 0\n\n\n80\n80\n\n\n\n\nCode\ntsla = tsla.dropna(subset=['Close_TSLA'])\nentries = tsla['Buy_Signal'].astype(bool)\nexits = tsla['Sell_Signal'].astype(bool)\n\n\n\n\nCode\nprice = tsla['Close_TSLA']\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    init_cash=100_000,\n    fees=0.001\n)\n\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\nStart                         2019-01-02 00:00:00\nEnd                           2025-03-04 00:00:00\nPeriod                                       1551\nStart Value                              100000.0\nEnd Value                           162759.235978\nTotal Return [%]                        62.759236\nBenchmark Return [%]                  1215.813231\nMax Gross Exposure [%]                      100.0\nTotal Fees Paid                      24054.581607\nMax Drawdown [%]                        55.348959\nMax Drawdown Duration                       730.0\nTotal Trades                                   80\nTotal Closed Trades                            80\nTotal Open Trades                               0\nOpen Trade PnL                                0.0\nWin Rate [%]                                 32.5\nBest Trade [%]                          46.283397\nWorst Trade [%]                         -9.410141\nAvg Winning Trade [%]                   11.344578\nAvg Losing Trade [%]                    -3.847352\nAvg Winning Trade Duration               7.076923\nAvg Losing Trade Duration                2.537037\nProfit Factor                            1.194803\nExpectancy                              784.49045\ndtype: object\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nThe backtest results show that while the strategy achieved a total return of approximately 62.76%, it significantly underperformed compared to a simple buy-and-hold strategy on TSLA, which yielded a 1215.81% return. The strategy executed 80 trades with a low win rate of 32.5%, indicating that most trades were unprofitable. Although it had a few strong winners, the average profit per trade was marginal, with a profit factor of 1.19. Additionally, the portfolio experienced a substantial maximum drawdown of 55.35% and a prolonged recovery period lasting two years, signaling high risk. Visuals further confirm that many trades resulted in small losses or gains, with only a few notable profitable exits. Overall, while the strategy demonstrates some profitability, its risk-return profile is weak and may require optimization in entry/exit logic, volatility filtering, or sentiment integration to compete with the benchmark performance."
  },
  {
    "objectID": "data_oracles_strategy.html#xly-analysis-results",
    "href": "data_oracles_strategy.html#xly-analysis-results",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "XLY Analysis Results",
    "text": "XLY Analysis Results\n\n\nCode\nurl = 'https://www.alphavantage.co/query?function=NEWS_SENTIMENT&date_from=20250101T0130&date_to=20250301T0130&limit=1000&tickers=XLY&apikey=PNM5EHRALIOT1CKJ'\n\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    sentiment_data = response.json()\n    sentiment_df = pd.DataFrame(sentiment_data['feed']) \n    print(sentiment_df.head())\nelse:\n    print(\"API call failed:\", response.status_code)\n\nsentiment_json = response.json()\nprint(sentiment_json)\n\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[1436], line 7\n      5 if response.status_code == 200:\n      6     sentiment_data = response.json()\n----&gt; 7     sentiment_df = pd.DataFrame(sentiment_data['feed']) \n      8     print(sentiment_df.head())\n      9 else:\n\nKeyError: 'feed'\n\n\n\n\n\nCode\nsentiment_data = []\nfor news_item in sentiment_json.get(\"feed\", []):\n    sentiment_data.append({\n            \"time_published\": pd.to_datetime(news_item[\"time_published\"]),\n            \"sentiment_score\": news_item[\"overall_sentiment_score\"],\n            \"sentiment_label\": news_item[\"overall_sentiment_label\"],\n    })\nsentiment_data = pd.DataFrame(sentiment_data)\n\n\n\n---------------------------------------------------------------------------\n\nNameError                                 Traceback (most recent call last)\n\nCell In[6], line 2\n\n      1 sentiment_data = []\n\n----&gt; 2 for news_item in sentiment_json.get(\"feed\", []):\n\n      3     sentiment_data.append({\n\n      4             \"time_published\": pd.to_datetime(news_item[\"time_published\"]),\n\n      5             \"sentiment_score\": news_item[\"overall_sentiment_score\"],\n\n      6             \"sentiment_label\": news_item[\"overall_sentiment_label\"],\n\n      7     })\n\n      8 sentiment_data = pd.DataFrame(sentiment_data)\n\n\n\nNameError: name 'sentiment_json' is not defined\n\n\n\n\n\nCode\nsentiment_data['time_published'] = sentiment_data['time_published'].dt.date\nsentiment_scores_filtered = sentiment_data[pd.to_datetime(sentiment_data['time_published']).isin(tsla.index)]\nsentiment_scores_filtered = sentiment_scores_filtered.groupby('time_published')['sentiment_score'].mean().reset_index()\n\n\n\n\nCode\n# Fix the multi-level column issue by selecting the 'Volume' column and resetting its name\nxly_volume = xly[('Volume', 'XLY')].rename('Volume')\n\n# Ensure the index of tsla_volume is a column and convert it to match the type of time_published\nxly_volume = xly_volume.reset_index()\nxly_volume['Date'] = pd.to_datetime(xly_volume['Date'])\n\n# Convert time_published to datetime\nsentiment_scores_filtered['time_published'] = pd.to_datetime(sentiment_scores_filtered['time_published'])\n# Merge the dataframes\nmerged_data = pd.merge(xly_volume, sentiment_scores_filtered, left_on='Date', right_on='time_published', how='inner')\nmerged_data['Weighted_Sentiment'] = merged_data['Volume'] * merged_data['sentiment_score']\nmerged_data['5_day_avg_sentiment'] = merged_data['Weighted_Sentiment'].rolling(window=5).mean()\nmerged_data['Buy_Condition'] = merged_data['5_day_avg_sentiment'] &gt; 0\nmerged_data['5_day_avg_sentiment_norm'] = merged_data['5_day_avg_sentiment']/merged_data['Volume'].mean()\n\n\n\n\nCode\n\n# Flatten MultiIndex columns \nxly.columns = [\n    '_'.join(col).strip() if isinstance(col, tuple) else col\n    for col in xly.columns\n]\n\n# Calculate True Range\nxly[\"prev_close\"] = xly[\"Close_XLY\"].shift(1)\nxly[\"tr1\"] = xly[\"High_XLY\"] - xly[\"Low_XLY\"]\nxly[\"tr2\"] = abs(xly[\"High_XLY\"] - xly[\"prev_close\"])\nxly[\"tr3\"] = abs(xly[\"Low_XLY\"] - xly[\"prev_close\"])\n\nxly[\"true_range\"] = xly[[\"tr1\", \"tr2\", \"tr3\"]].max(axis=1)\n\n# 10-day ATR\nxly[\"ATR_10\"] = xly[\"true_range\"].rolling(window=10).mean()\n\n# ---- STEP 4: Calculate ATR as a percentage of closing price ----\nxly[\"atr_pct\"] = xly[\"ATR_10\"] / xly[\"Close_XLY\"]\n\n# allocating the capital\n\ndef position_size(row):\n    if row[\"atr_pct\"] &lt; 0.03:  # &lt; 3% volatility → low risk\n        return 0.01  # allocate 1% of capital\n    else:  # ≥ 3% volatility → high risk\n        return 0.005  # allocate 0.5% of capital\n\nxly[\"position_size\"] = xly.apply(position_size, axis=1)\n\n# ---- STEP 6: Optional - Capital allocation per trade ----\n#capital = 100000 # Example: $100K total portfolio\n#xly[\"allocation_dollars\"] = xly[\"position_size\"] * capital\n\n# ---- Preview ----\nprint(xly[[\"Close_XLY\", \"ATR_10\", \"atr_pct\", \"position_size\"]].tail(10))\n\n\n             Close_XLY    ATR_10   atr_pct  position_size\nDate                                                     \n2025-02-19  225.618988  2.870099  0.012721           0.01\n2025-02-20  223.674316  2.919964  0.013055           0.01\n2025-02-21  217.790527  3.453495  0.015857           0.01\n2025-02-24  216.972778  3.270997  0.015076           0.01\n2025-02-25  215.835892  3.511334  0.016269           0.01\n2025-02-26  214.948349  3.602083  0.016758           0.01\n2025-02-27  211.846878  3.751672  0.017709           0.01\n2025-02-28  215.367203  3.836439  0.017813           0.01\n2025-03-03  211.398117  4.429805  0.020955           0.01\n2025-03-04  207.668396  4.845659  0.023334           0.01\n\n\n\n\nCode\nimport plotly.express as px\nfig = px.line(xly, x=xly.index, y=\"atr_pct\", title=\"ATR% Over Time\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nimport plotly.express as px\n\n# Filter only 2025 data\nxly_2025 = xly[xly.index.year == 2025]\n\n# Plot\nfig = px.line(xly_2025, x=xly_2025.index, y=\"atr_pct\", title=\"ATR% Over Time (2025 Only)\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nmerged_data = pd.merge(merged_data, xly, on='Date', how='left')\n\n\n\n\nCode\n# Calculate ATR percentage\nmerged_data['atr_pct'] = merged_data['ATR_10'] / merged_data['Close_XLY']\n\n# Vortex crossover logic\nmerged_data['VI_Cross_Up'] = (merged_data['VI+_'] &gt; merged_data['VI-_']) & (merged_data['VI+_'].shift(1) &lt;= merged_data['VI-_'].shift(1))\nmerged_data['VI_Cross_Down'] = (merged_data['VI-_'] &gt; merged_data['VI+_']) & (merged_data['VI-_'].shift(1) &lt;= merged_data['VI+_'].shift(1))\n\n# Initialize signal & state columns\nmerged_data['Buy_Signal'] = False\nmerged_data['Sell_Signal'] = False\nmerged_data['Position'] = 0\nmerged_data['Entry_Type'] = None  # aggressive/conservative\n\n# Trailing stop logic variables\nin_position = False\npeak_price = 0\n\nfor i in range(1, len(merged_data)):\n    row = merged_data.iloc[i]\n    idx = merged_data.index[i]\n    # Buy condition\n    if not in_position or row['VI_Cross_Up'] or row['5_day_avg_sentiment_norm']&gt;0:\n        merged_data.at[idx, 'Buy_Signal'] = True\n        merged_data.at[idx, 'Position'] = 1\n        in_position = True\n        peak_price = row['Close_XLY']\n\n        # Entry Type: aggressive if ATR &lt; 3%, else conservative\n        if row['atr_pct'] &lt; 0.03:\n            merged_data.at[idx, 'Entry_Type'] = 'aggressive'\n        else:\n            merged_data.at[idx, 'Entry_Type'] = 'conservative'\n\n    # While in position, check for trailing stop or VI cross down\n    elif in_position:\n        current_price = row['Close_XLY']\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03 or row['VI_Cross_Down']:\n            merged_data.at[idx, 'Sell_Signal'] = True\n            merged_data.at[idx, 'Position'] = 0\n            in_position = False\n        else:\n            merged_data.at[idx, 'Position'] = 1\n\n# Show result counts\nprint(\"Buy signals:\", merged_data['Buy_Signal'].sum())\nprint(\"Sell signals:\", merged_data['Sell_Signal'].sum())\nprint(\"Aggressive entries:\", (merged_data['Entry_Type'] == 'aggressive').sum())\nprint(\"Conservative entries:\", (merged_data['Entry_Type'] == 'conservative').sum())\n\n\nBuy signals: 17\nSell signals: 1\nAggressive entries: 17\nConservative entries: 0\n\n\n\n\nCode\nfig = go.Figure()\n\n# Plot merged_data closing price\nfig.add_trace(go.Scatter(\n    x=merged_data.index, \n    y=merged_data['Close_XLY'], \n    mode='lines', \n    name='merged_data Price', \n    line=dict(color='blue')\n))\n\n# Aggressive buys\nfig.add_trace(go.Scatter(\n    x=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'aggressive')].index,\n    y=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'aggressive')]['Close_XLY'],\n    mode='markers',\n    name='Buy (Aggressive)',\n    marker=dict(symbol='triangle-up', color='limegreen', size=10)\n))\n\n# Conservative buys\nfig.add_trace(go.Scatter(\n    x=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'conservative')].index,\n    y=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'conservative')]['Close_XLY'],\n    mode='markers',\n    name='Buy (Conservative)',\n    marker=dict(symbol='triangle-up', color='green', size=10)\n))\n\n# Sells\nfig.add_trace(go.Scatter(\n    x=merged_data[merged_data['Sell_Signal']].index,\n    y=merged_data[merged_data['Sell_Signal']]['Close_XLY'],\n    mode='markers',\n    name='Sell Signal',\n    marker=dict(symbol='triangle-down', color='red', size=10)\n))\n\nfig.update_layout(\n    title='merged_data Buy/Sell Signals Over Time',\n    xaxis_title='Date',\n    yaxis_title='Price (USD)',\n    template='plotly_white',\n    height=600\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Ensure 'Date' is datetime and set as index if needed\nmerged_data['Date'] = pd.to_datetime(merged_data['Date'])\n\nfig = go.Figure()\n\n# Plot 5-day Avg Sentiment\nfig.add_trace(go.Scatter(\n    x=merged_data['Date'],\n    y=merged_data['5_day_avg_sentiment_norm'],\n    mode='lines+markers',\n    name='5-Day Avg Sentiment',\n    line=dict(color='blue')\n))\n\n# Plot ATR %\nfig.add_trace(go.Scatter(\n    x=merged_data['Date'],\n    y=merged_data['atr_pct'],\n    mode='lines+markers',\n    name='ATR %',\n    yaxis='y2',\n    line=dict(color='orange')\n))\n\n# Optional: Highlight Buy Signal Dates (even though there are none now)\nfig.add_trace(go.Scatter(\n    x=merged_data.loc[merged_data['Buy_Signal'], 'Date'],\n    y=merged_data.loc[merged_data['Buy_Signal'], '5_day_avg_sentiment_norm'],\n    mode='markers',\n    marker=dict(color='green', size=10, symbol='star'),\n    name='Buy Signal'\n))\n\n# Add dual axis layout\nfig.update_layout(\n    title=\"5-Day Sentiment vs ATR % (with Buy Signals)\",\n    xaxis_title='Date',\n    yaxis=dict(title='5-Day Avg Sentiment'),\n    yaxis2=dict(title='ATR %', overlaying='y', side='right'),\n    legend=dict(x=0.01, y=0.99),\n    height=500\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=merged_data.index, y=merged_data['Close_XLY'], mode='lines', name='merged_data Price'))\n\n# Buy markers\nfig.add_trace(go.Scatter(\n    x=merged_data[merged_data['Buy_Signal']].index,\n    y=merged_data[merged_data['Buy_Signal']]['Close_XLY'],\n    mode='markers',\n    marker=dict(symbol='triangle-up', size=10, color='green'),\n    name='Buy Signal'\n))\n\n# Sell markers\nfig.add_trace(go.Scatter(\n    x=merged_data[merged_data['Sell_Signal']].index,\n    y=merged_data[merged_data['Sell_Signal']]['Close_XLY'],\n    mode='markers',\n    marker=dict(symbol='triangle-down', size=10, color='red'),\n    name='Sell Signal'\n))\n\nfig.update_layout(title='XLY Buy & Sell Signals', template='plotly_white')\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\ncapital = 100000\nin_position = False\nentry_price = 0\nposition_value = 0\ncash = capital\nreturns = []\n\nfor i in range(len(merged_data)):\n    row = merged_data.iloc[i]\n    \n    # Buy\n    if row['Buy_Signal'] and not in_position:\n        position_size = row['position_size']\n        position_value = cash * position_size\n        entry_price = row['Close_XLY']\n        shares_bought = position_value / entry_price\n        cash -= position_value\n        in_position = True\n        \n    # Sell\n    elif row['Sell_Signal'] and in_position:\n        exit_price = row['Close_XLY']\n        proceeds = shares_bought * exit_price\n        profit = proceeds - position_value\n        cash += proceeds\n        returns.append(profit)\n        in_position = False\n        position_value = 0\n        entry_price = 0\n\n# Final capital\nfinal_value = cash + (shares_bought * row['Close_XLY'] if in_position else 0)\ntotal_return = final_value - capital\n\nprint(f\"Final Capital: ${final_value:.2f}\")\nprint(f\"Total Return: ${total_return:.2f}\")\nprint(f\"Total Trades: {len(returns)}\")\nprint(f\"Average Profit per Trade: ${np.mean(returns):.2f}\")\n\n\nFinal Capital: $99904.34\nTotal Return: $-95.66\nTotal Trades: 1\nAverage Profit per Trade: $-15.67\n\n\n\nWithout sentiment code\n\n\nCode\n# Without sentiment score\nxly_copy = xly.copy()\nxly_copy['atr_pct'] = xly_copy['ATR_10'] / xly_copy['Close_XLY']\n\n# Create Buy Signal (assuming VI_Cross_Up is defined elsewhere)\nxly_copy['Buy_Signal'] = xly_copy['VI+_'] &gt; xly_copy['VI-_']  # Vortex crossover\n# + add any other buy conditions here...\n\n# Create Sell Signal (basic)\nxly_copy['Sell_Signal'] = xly_copy['VI-_'] &gt; xly_copy['VI+_']\n\n# Initialize position state\nxly_copy['Position'] = 0\npeak_price = 0\n\nfor i in range(1, len(xly_copy)):\n    if xly_copy['Buy_Signal'].iloc[i]:\n        xly_copy.at[xly_copy.index[i], 'Position'] = 1\n        peak_price = xly_copy['Close_XLY'].iloc[i]\n    elif xly_copy['Position'].iloc[i - 1] == 1:\n        current_price = xly_copy['Close_XLY'].iloc[i]\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03:\n            xly_copy.at[xly_copy.index[i], 'Sell_Signal'] = True  # trailing stop\n            xly_copy.at[xly_copy.index[i], 'Position'] = 0\n        else:\n            xly_copy.at[xly_copy.index[i], 'Position'] = 1\n\n\n\n\nCode\ncapital = 100000\nin_position = False\nentry_price = 0\nposition_value = 0\ncash = capital\nreturns = []\n\nfor i in range(len(xly_copy)):\n    row = xly_copy.iloc[i]\n    \n    # Buy\n    if row['Buy_Signal'] and not in_position:\n        position_size = row['position_size']\n        position_value = cash * position_size\n        entry_price = row['Close_XLY']\n        shares_bought = position_value / entry_price\n        cash -= position_value\n        in_position = True\n        \n    # Sell\n    elif row['Sell_Signal'] and in_position:\n        exit_price = row['Close_XLY']\n        proceeds = shares_bought * exit_price\n        profit = proceeds - position_value\n        cash += proceeds\n        returns.append(profit)\n        in_position = False\n        position_value = 0\n        entry_price = 0\n\n# Final capital\nfinal_value = cash + (shares_bought * row['Close_XLY'] if in_position else 0)\ntotal_return = final_value - capital\n\nprint(f\"Final Capital: ${final_value:.2f}\")\nprint(f\"Total Return: ${total_return:.2f}\")\nprint(f\"Total Trades: {len(returns)}\")\nprint(f\"Average Profit per Trade: ${np.mean(returns):.2f}\")\n\n\nFinal Capital: $100732.95\nTotal Return: $732.95\nTotal Trades: 75\nAverage Profit per Trade: $9.77\n\n\n\n\nCode\nxly = xly_copy.dropna(subset=['Close_XLY'])\nentries = xly_copy['Buy_Signal'].astype(bool)\nexits = xly_copy['Sell_Signal'].astype(bool)\n\nprice = xly_copy['Close_XLY']\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    init_cash=100_000,\n    fees=0.001\n)\n\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\n\n---------------------------------------------------------------------------\n\nModuleNotFoundError                       Traceback (most recent call last)\n\nCell In[23], line 1\n\n----&gt; 1 import vectorbt as vbt\n\n      3 xly = xly_copy.dropna(subset=['Close_XLY'])\n\n      4 entries = xly_copy['Buy_Signal'].astype(bool)\n\n\n\nModuleNotFoundError: No module named 'vectorbt'\n\n\n\n\n\nCode\n# Make sure index is datetime and 'Close_TSLA' exists\nprice = merged_data['Close_XLY']\n\n# Generate entries and exits from your signals\nentries = merged_data['Buy_Signal']\nexits = merged_data['Sell_Signal']\n\n# Create portfolio\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    size=np.nan,  # Let it auto-calculate position size if fixed capital\n    init_cash=100_000,\n    fees=0.001,  # 0.1% per trade\n    slippage=0.0005  # Optional\n)\n\n# Plot portfolio value\nportfolio.plot().show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Summary stats\nprint(portfolio.stats())\n\n# Equity curve\nportfolio.plot().show()\n\n\nStart                              0.000000\nEnd                               19.000000\nPeriod                            20.000000\nStart Value                   100000.000000\nEnd Value                     100000.000000\nTotal Return [%]                   0.000000\nBenchmark Return [%]             -10.163929\nMax Gross Exposure [%]             0.000000\nTotal Fees Paid                    0.000000\nMax Drawdown [%]                        NaN\nMax Drawdown Duration                   NaN\nTotal Trades                       0.000000\nTotal Closed Trades                0.000000\nTotal Open Trades                  0.000000\nOpen Trade PnL                     0.000000\nWin Rate [%]                            NaN\nBest Trade [%]                          NaN\nWorst Trade [%]                         NaN\nAvg Winning Trade [%]                   NaN\nAvg Losing Trade [%]                    NaN\nAvg Winning Trade Duration              NaN\nAvg Losing Trade Duration               NaN\nProfit Factor                           NaN\nExpectancy                              NaN\ndtype: float64\n\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nxly = merged_data.dropna(subset=['Close_XLY'])\nentries = merged_data['Buy_Signal'].astype(bool)\nexits = merged_data['Sell_Signal'].astype(bool)\n\n\n\n\nCode\nprice = merged_data['Close_XLY']\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    init_cash=100_000,\n    fees=0.001\n)\n\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/Users/begiii/Documents/SPRING 2025/Hackathon_Spring_2025/Vortex-Sentiment-Adaptive-Volatility-VSAV-Strategy/.venv/lib/python3.9/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nStart                              0.000000\nEnd                               19.000000\nPeriod                            20.000000\nStart Value                   100000.000000\nEnd Value                      90286.704981\nTotal Return [%]                  -9.713295\nBenchmark Return [%]             -10.163929\nMax Gross Exposure [%]           100.000000\nTotal Fees Paid                  296.373903\nMax Drawdown [%]                   9.980462\nMax Drawdown Duration             17.000000\nTotal Trades                       2.000000\nTotal Closed Trades                1.000000\nTotal Open Trades                  1.000000\nOpen Trade PnL                 -7950.098224\nWin Rate [%]                       0.000000\nBest Trade [%]                    -1.764960\nWorst Trade [%]                   -1.764960\nAvg Winning Trade [%]                   NaN\nAvg Losing Trade [%]              -1.764960\nAvg Winning Trade Duration              NaN\nAvg Losing Trade Duration          2.000000\nProfit Factor                      0.000000\nExpectancy                     -1763.196795\ndtype: float64\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  },
  {
    "objectID": "data_oracles_strategy.html#spy-analysis-results",
    "href": "data_oracles_strategy.html#spy-analysis-results",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "SPY Analysis Results",
    "text": "SPY Analysis Results\n\n\nCode\n# Flatten MultiIndex columns \nspy.columns = [\n    '_'.join(col).strip() if isinstance(col, tuple) else col\n    for col in spy.columns\n]\n\n# Calculate True Range\nspy[\"prev_close\"] = spy[\"Close_SPY\"].shift(1)\nspy[\"tr1\"] = spy[\"High_SPY\"] - spy[\"Low_SPY\"]\nspy[\"tr2\"] = abs(spy[\"High_SPY\"] - spy[\"prev_close\"])\nspy[\"tr3\"] = abs(spy[\"Low_SPY\"] - spy[\"prev_close\"])\n\nspy[\"true_range\"] = spy[[\"tr1\", \"tr2\", \"tr3\"]].max(axis=1)\n\n# 10-day ATR\nspy[\"ATR_10\"] = spy[\"true_range\"].rolling(window=10).mean()\n\n# ---- STEP 4: Calculate ATR as a percentage of closing price ----\nspy[\"atr_pct\"] = spy[\"ATR_10\"] / spy[\"Close_SPY\"]\n\n# allocating the capital\n\ndef position_size(row):\n    if row[\"atr_pct\"] &lt; 0.03:  # &lt; 3% volatility → low risk\n        return 0.01  # allocate 1% of capital\n    else:  # ≥ 3% volatility → high risk\n        return 0.005  # allocate 0.5% of capital\n\nspy[\"position_size\"] = spy.apply(position_size, axis=1)\n\n# ---- STEP 6: Optional - Capital allocation per trade ----\n#capital = 100000 # Example: $100K total portfolio\n#spy[\"allocation_dollars\"] = spy[\"position_size\"] * capital\n\n# ---- Preview ----\nprint(spy[[\"Close_SPY\", \"ATR_10\", \"atr_pct\", \"position_size\"]].tail(10))\n\n\n             Close_SPY    ATR_10   atr_pct  position_size\nDate                                                     \n2025-02-19  611.091675  4.794563  0.007846           0.01\n2025-02-20  608.549377  4.806522  0.007898           0.01\n2025-02-21  598.140686  5.513399  0.009218           0.01\n2025-02-24  595.418884  5.359863  0.009002           0.01\n2025-02-25  592.457764  5.718790  0.009653           0.01\n2025-02-26  592.756836  6.146507  0.010369           0.01\n2025-02-27  583.295288  6.801538  0.011661           0.01\n2025-02-28  592.397949  7.353875  0.012414           0.01\n2025-03-03  582.019165  8.901222  0.015294           0.01\n2025-03-04  575.129883  9.901217  0.017216           0.01\n\n\n\n\nCode\nfig = px.line(spy, x=spy.index, y=\"atr_pct\", title=\"ATR% Over Time\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Filter only 2025 data\nspy_2025 = spy[spy.index.year == 2025]\n\n# Plot\nfig = px.line(spy_2025, x=spy_2025.index, y=\"atr_pct\", title=\"ATR% Over Time (2025 Only)\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Without sentiment score\nspy_copy = spy.copy()\nspy_copy['atr_pct'] = spy_copy['ATR_10'] / spy_copy['Close_SPY']\n\n# Create Buy Signal (assuming VI_Cross_Up is defined elsewhere)\nspy_copy['Buy_Signal'] = spy_copy['VI+_'] &gt; spy_copy['VI-_']  # Vortex crossover\n\n# Create Sell Signal (basic)\nspy_copy['Sell_Signal'] = spy_copy['VI-_'] &gt; spy_copy['VI+_']\n\n# Initialize position state\nspy_copy['Position'] = 0\npeak_price = 0\n\nfor i in range(1, len(spy_copy)):\n    if spy_copy['Buy_Signal'].iloc[i]:\n        spy_copy.at[spy_copy.index[i], 'Position'] = 1\n        peak_price = spy_copy['Close_SPY'].iloc[i]\n    elif spy_copy['Position'].iloc[i - 1] == 1:\n        current_price = spy_copy['Close_SPY'].iloc[i]\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03:\n            spy_copy.at[spy_copy.index[i], 'Sell_Signal'] = True  # trailing stop\n            spy_copy.at[spy_copy.index[i], 'Position'] = 0\n        else:\n            spy_copy.at[spy_copy.index[i], 'Position'] = 1\n\n\n\n\nCode\ncapital = 100000\nin_position = False\nentry_price = 0\nposition_value = 0\ncash = capital\nreturns = []\n\nfor i in range(len(spy_copy)):\n    row = spy_copy.iloc[i]\n    \n    # Buy\n    if row['Buy_Signal'] and not in_position:\n        position_size = row['position_size']\n        position_value = cash * position_size\n        entry_price = row['Close_SPY']\n        shares_bought = position_value / entry_price\n        cash -= position_value\n        in_position = True\n        \n    # Sell\n    elif row['Sell_Signal'] and in_position:\n        exit_price = row['Close_SPY']\n        proceeds = shares_bought * exit_price\n        profit = proceeds - position_value\n        cash += proceeds\n        returns.append(profit)\n        in_position = False\n        position_value = 0\n        entry_price = 0\n\n# Final capital\nfinal_value = cash + (shares_bought * row['Close_SPY'] if in_position else 0)\ntotal_return = final_value - capital\n\nprint(f\"Final Capital: ${final_value:.2f}\")\nprint(f\"Total Return: ${total_return:.2f}\")\nprint(f\"Total Trades: {len(returns)}\")\nprint(f\"Average Profit per Trade: ${np.mean(returns):.2f}\")\n\n\nFinal Capital: $100515.03\nTotal Return: $515.03\nTotal Trades: 56\nAverage Profit per Trade: $9.20\n\n\n\n\nCode\nimport vectorbt as vbt\n\nspy = spy_copy.dropna(subset=['Close_SPY'])\nentries = spy_copy['Buy_Signal'].astype(bool)\nexits = spy_copy['Sell_Signal'].astype(bool)\n\nprice = spy_copy['Close_SPY']\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    init_cash=100_000,\n    fees=0.001\n)\n\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nStart                         2019-01-02 00:00:00\nEnd                           2025-03-04 00:00:00\nPeriod                                       1551\nStart Value                              100000.0\nEnd Value                           149876.276862\nTotal Return [%]                        49.876277\nBenchmark Return [%]                   153.411688\nMax Gross Exposure [%]                      100.0\nTotal Fees Paid                      14500.399389\nMax Drawdown [%]                        19.809422\nMax Drawdown Duration                       584.0\nTotal Trades                                   56\nTotal Closed Trades                            56\nTotal Open Trades                               0\nOpen Trade PnL                                0.0\nWin Rate [%]                            55.357143\nBest Trade [%]                           7.385103\nWorst Trade [%]                         -9.885439\nAvg Winning Trade [%]                    3.135412\nAvg Losing Trade [%]                    -2.130086\nAvg Winning Trade Duration              28.258065\nAvg Losing Trade Duration                    7.56\nProfit Factor                              1.7122\nExpectancy                             890.647801\ndtype: object\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  },
  {
    "objectID": "data_oracles_strategy.html#optimization",
    "href": "data_oracles_strategy.html#optimization",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "Optimization",
    "text": "Optimization\n\n\nCode\ntsla = yf.download('TSLA', start='2019-01-01', end='2025-03-05')\nxly = yf.download('XLY', start='2019-01-01', end='2025-03-05')\nspy = yf.download('SPY', start='2019-01-01', end='2025-03-05')\n\n\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\nCode\ndef calculate_vortex(df, value, n):\n    \"\"\"Calculate Vortex Indicator VI+ and VI-.\"\"\"\n    high = df[(\"High_\"+value)]\n    low = df[(\"Low_\"+value)]\n    close = df[(\"Close_\"+value)]\n\n    vm_plus = abs(high - low.shift(1))   # |Today's High - Yesterday's Low|\n    vm_minus = abs(low - high.shift(1))  # |Today's Low - Yesterday's High|\n\n    tr = pd.concat([\n        high - low,\n        abs(high - close.shift(1)),\n        abs(low - close.shift(1))\n    ], axis=1).max(axis=1)\n\n    sum_vm_plus = vm_plus.rolling(window=n).sum()\n    sum_vm_minus = vm_minus.rolling(window=n).sum()\n    sum_tr = tr.rolling(window=n).sum()\n\n    vi_plus = sum_vm_plus / sum_tr\n    vi_minus = sum_vm_minus / sum_tr\n\n    return vi_plus, vi_minus\n\n\n\n\nCode\ntsla.columns = [\n    '_'.join(col).strip() if isinstance(col, tuple) else col\n    for col in tsla.columns\n]\n\n\n\n\nCode\n# Define a list of different smoothing periods to test for the Vortex Indicator\nperiods = [7, 14, 21, 30]\nresults = {}  # Dictionary to store performance metrics for each period\n\n# Loop through each smoothing period\nfor n in periods:\n    # === Compute Vortex Indicator for the given period ===\n    tsla[f'VI+_{n}'], tsla[f'VI-_{n}'] = calculate_vortex(tsla, 'TSLA', n)\n\n    # === Generate Buy/Sell signals based on crossover logic ===\n    # Buy when VI+ crosses above VI-\n    tsla[f'Buy_{n}'] = tsla[f'VI+_{n}'] &gt; tsla[f'VI-_{n}']\n    # Sell when VI- crosses above VI+\n    tsla[f'Sell_{n}'] = tsla[f'VI-_{n}'] &gt; tsla[f'VI+_{n}']\n\n    # === Convert boolean signals to actual entry/exit Series ===\n    entries = tsla[f'Buy_{n}']\n    exits = tsla[f'Sell_{n}']\n\n    # === Run a backtest using vectorbt Portfolio object ===\n    portfolio = vbt.Portfolio.from_signals(\n        close=tsla['Close_TSLA'],  # TSLA closing prices\n        entries=entries,\n        exits=exits,\n        size=1,  # Assume buying 1 share per trade\n        init_cash=10_000  # Initial capital for backtest\n    )\n\n    # === Store backtest performance metrics in results dict ===\n    stats = portfolio.stats()\n    results[n] = stats\n\n# Identify the period with the highest total return\nbest_period = max(results, key=lambda x: results[x]['Total Return [%]'])\nprint(f\"✅ Best Performing Period: {best_period} days\")\n\n# Rebuild portfolio using the best period to visualize it\nportfolio = vbt.Portfolio.from_signals(\n    close=tsla['Close_TSLA'],\n    entries=tsla[f'VI+_{best_period}'] &gt; tsla[f'VI-_{best_period}'],\n    exits=tsla[f'VI-_{best_period}'] &gt; tsla[f'VI+_{best_period}'],\n    size=1,\n    init_cash=10_000\n)\n\n# Plot the results of the best strategy\nportfolio.plot().show()\nprint(portfolio.stats())\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\n✅ Best Performing Period: 7 days\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nStart                         2019-01-02 00:00:00\nEnd                           2025-03-04 00:00:00\nPeriod                                       1551\nStart Value                               10000.0\nEnd Value                            10480.194603\nTotal Return [%]                         4.801946\nBenchmark Return [%]                  1215.813231\nMax Gross Exposure [%]                   4.554966\nTotal Fees Paid                               0.0\nMax Drawdown [%]                         0.793073\nMax Drawdown Duration                       351.0\nTotal Trades                                  113\nTotal Closed Trades                           113\nTotal Open Trades                               0\nOpen Trade PnL                                0.0\nWin Rate [%]                            44.247788\nBest Trade [%]                         128.434899\nWorst Trade [%]                        -15.721837\nAvg Winning Trade [%]                   14.052436\nAvg Losing Trade [%]                    -4.125181\nAvg Winning Trade Duration                  11.44\nAvg Losing Trade Duration                4.206349\nProfit Factor                            2.096188\nExpectancy                                4.24951\ndtype: object"
  },
  {
    "objectID": "data_oracles_strategy.html#peer-comparison-apple-analysis-results",
    "href": "data_oracles_strategy.html#peer-comparison-apple-analysis-results",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "Peer Comparison: Apple Analysis Results",
    "text": "Peer Comparison: Apple Analysis Results\n\n\nCode\nappl = yf.download('AAPL', start='2019-01-01', end='2025-03-05')\n\n\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\nCode\nappl.columns = [\n    '_'.join(col).strip() if isinstance(col, tuple) else col\n    for col in appl.columns\n]\n\n\n\n\nCode\ndef calculate_vortex(df, value, n):\n    \"\"\"Calculate Vortex Indicator VI+ and VI-.\"\"\"\n    high = df[(\"High_\"+value)]\n    low = df[(\"Low_\"+value)]\n    close = df[(\"Close_\"+value)]\n\n    vm_plus = abs(high - low.shift(1))   # |Today's High - Yesterday's Low|\n    vm_minus = abs(low - high.shift(1))  # |Today's Low - Yesterday's High|\n\n    tr = pd.concat([\n        high - low,\n        abs(high - close.shift(1)),\n        abs(low - close.shift(1))\n    ], axis=1).max(axis=1)\n\n    sum_vm_plus = vm_plus.rolling(window=n).sum()\n    sum_vm_minus = vm_minus.rolling(window=n).sum()\n    sum_tr = tr.rolling(window=n).sum()\n\n    vi_plus = sum_vm_plus / sum_tr\n    vi_minus = sum_vm_minus / sum_tr\n\n    return vi_plus, vi_minus\n\n\n\n\nCode\nappl['VI+_'], appl['VI-_'] = calculate_vortex(appl, 'AAPL', 14)\n\n\n\n\nCode\nimport json\nimport pandas as pd\n\n# Load from file\nwith open(\"AAPL_sentiment_raw.json\", \"r\") as f:\n    sentiment_json = json.load(f)\n\n# Extract feed\nsentiment_feed = sentiment_json.get(\"feed\", [])\n\n# Extract useful fields\nsentiment_data = []\n\nfor item in sentiment_feed:\n    try:\n        sentiment_data.append({\n            \"time_published\": pd.to_datetime(item[\"time_published\"]),\n            \"sentiment_score\": float(item[\"overall_sentiment_score\"]),\n            \"sentiment_label\": item[\"overall_sentiment_label\"],\n        })\n    except (KeyError, ValueError, TypeError):\n        continue  # Skip malformed rows\n\n# Convert to DataFrame\nsentiment_df = pd.DataFrame(sentiment_data)\nsentiment_df.set_index(\"time_published\", inplace=True)\n\n# View result\nprint(sentiment_df.head())\nprint(sentiment_df.info())\n\n\n                     sentiment_score   sentiment_label\ntime_published                                        \n2025-03-01 00:00:18         0.225994  Somewhat-Bullish\n2025-02-28 22:06:00         0.291136  Somewhat-Bullish\n2025-02-28 17:55:55         0.082801           Neutral\n2025-02-28 17:00:45         0.374552           Bullish\n2025-02-28 15:00:46         0.287114  Somewhat-Bullish\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nDatetimeIndex: 669 entries, 2025-03-01 00:00:18 to 2025-01-15 14:45:51\nData columns (total 2 columns):\n #   Column           Non-Null Count  Dtype  \n---  ------           --------------  -----  \n 0   sentiment_score  669 non-null    float64\n 1   sentiment_label  669 non-null    object \ndtypes: float64(1), object(1)\nmemory usage: 15.7+ KB\nNone\n\n\n\n\nCode\nsentiment_data = []\nfor news_item in sentiment_json.get(\"feed\", []):\n    sentiment_data.append({\n            \"time_published\": pd.to_datetime(news_item[\"time_published\"]),\n            \"sentiment_score\": news_item[\"overall_sentiment_score\"],\n            \"sentiment_label\": news_item[\"overall_sentiment_label\"],\n    })\nsentiment_data = pd.DataFrame(sentiment_data)\nsentiment_data['time_published'] = sentiment_data['time_published'].dt.date\n\n\n\n\nCode\nsentiment_scores_filtered = sentiment_data[pd.to_datetime(sentiment_data['time_published']).isin(appl.index)]\nsentiment_scores_filtered = sentiment_scores_filtered.groupby('time_published')['sentiment_score'].mean().reset_index()\nprint(len(sentiment_scores_filtered))\n\n\n31\n\n\n\n\nCode\nappl_volume = appl[('Volume_AAPL')].reset_index()\nappl_volume['Date'] = pd.to_datetime(appl_volume['Date'])\n\nsentiment_scores_filtered['time_published'] = pd.to_datetime(sentiment_scores_filtered['time_published'])\n\nmerged_data = pd.merge(appl_volume, sentiment_scores_filtered, left_on='Date', right_on='time_published', how='inner')\nmerged_data['Weighted_Sentiment'] = merged_data['Volume_AAPL'] * merged_data['sentiment_score']\nmerged_data['5_day_avg_sentiment'] = merged_data['Weighted_Sentiment'].rolling(window=5).mean()\nmerged_data['Buy_Condition'] = merged_data['5_day_avg_sentiment'] &gt; 0\nmerged_data['5_day_avg_sentiment_norm'] = merged_data['5_day_avg_sentiment']/merged_data['Volume_AAPL'].mean()\n\nmerged_data.head()\n\n\n\n\n\n\n\n\n\nDate\nVolume_AAPL\ntime_published\nsentiment_score\nWeighted_Sentiment\n5_day_avg_sentiment\nBuy_Condition\n5_day_avg_sentiment_norm\n\n\n\n\n0\n2025-01-15\n39832000\n2025-01-15\n0.223177\n8.889575e+06\nNaN\nFalse\nNaN\n\n\n1\n2025-01-16\n71759100\n2025-01-16\n0.237567\n1.704756e+07\nNaN\nFalse\nNaN\n\n\n2\n2025-01-17\n68488300\n2025-01-17\n0.130304\n8.924326e+06\nNaN\nFalse\nNaN\n\n\n3\n2025-01-21\n98070400\n2025-01-21\n0.169273\n1.660064e+07\nNaN\nFalse\nNaN\n\n\n4\n2025-01-22\n64126500\n2025-01-22\n0.182421\n1.169803e+07\n1.263203e+07\nTrue\n0.231401\n\n\n\n\n\n\n\n\n\nCode\n# Calculate True Range\nappl[\"prev_close\"] = appl[\"Close_AAPL\"].shift(1)\nappl[\"tr1\"] = appl[\"High_AAPL\"] - appl[\"Low_AAPL\"]\nappl[\"tr2\"] = abs(appl[\"High_AAPL\"] - appl[\"prev_close\"])\nappl[\"tr3\"] = abs(appl[\"Low_AAPL\"] - appl[\"prev_close\"])\n\nappl[\"true_range\"] = appl[[\"tr1\", \"tr2\", \"tr3\"]].max(axis=1)\n\n# 10-day ATR\nappl[\"ATR_10\"] = appl[\"true_range\"].rolling(window=10).mean()\n\n# ---- STEP 4: Calculate ATR as a percentage of closing price ----\nappl[\"atr_pct\"] = appl[\"ATR_10\"] / appl[\"Close_AAPL\"]\n\n# allocating the capital\n\ndef position_size(row):\n    if row[\"atr_pct\"] &lt; 0.03:  # &lt; 3% volatility → low risk\n        return 0.01  # allocate 1% of capital\n    else:  # ≥ 3% volatility → high risk\n        return 0.005  # allocate 0.5% of capital\n\nappl[\"position_size\"] = appl.apply(position_size, axis=1)\n\nprint(appl[[\"Close_AAPL\", \"ATR_10\", \"atr_pct\", \"position_size\"]].tail(10))\n\n\n            Close_AAPL    ATR_10   atr_pct  position_size\nDate                                                     \n2025-02-19  244.869995  4.939392  0.020171           0.01\n2025-02-20  245.830002  4.735891  0.019265           0.01\n2025-02-21  245.550003  4.746260  0.019329           0.01\n2025-02-24  247.100006  4.517000  0.018280           0.01\n2025-02-25  247.039993  4.687000  0.018973           0.01\n2025-02-26  240.360001  4.719998  0.019637           0.01\n2025-02-27  237.300003  4.631998  0.019520           0.01\n2025-02-28  241.839996  5.143999  0.021270           0.01\n2025-03-03  238.029999  5.479999  0.023022           0.01\n2025-03-04  235.929993  5.685001  0.024096           0.01\n\n\n\n\nCode\nimport plotly.express as px\nfig = px.line(appl, x=appl.index, y=\"atr_pct\", title=\"AAPL ATR% Over Time\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\n# Filter only 2025 data\nappl_2025 = appl[appl.index.year == 2025]\nfig = px.line(appl_2025, x=appl_2025.index, y=\"atr_pct\", title=\"AAPL ATR% Over Time (2025 Only)\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nmerged_data = pd.merge(merged_data, appl, on='Date', how='left')\n\n\n\n\nCode\n# Calculate ATR percentage\nmerged_data['atr_pct'] = merged_data['ATR_10'] / merged_data['Close_AAPL']\n\n# Vortex crossover logic\nmerged_data['VI_Cross_Up'] = (merged_data['VI+_'] &gt; merged_data['VI-_']) & (merged_data['VI+_'].shift(1) &lt;= merged_data['VI-_'].shift(1))\nmerged_data['VI_Cross_Down'] = (merged_data['VI-_'] &gt; merged_data['VI+_']) & (merged_data['VI-_'].shift(1) &lt;= merged_data['VI+_'].shift(1))\n\n# Initialize signal & state columns\nmerged_data['Buy_Signal'] = False\nmerged_data['Sell_Signal'] = False\nmerged_data['Position'] = 0\nmerged_data['Entry_Type'] = None  # aggressive/conservative\n\n# Trailing stop logic variables\nin_position = False\npeak_price = 0\n\nfor i in range(1, len(merged_data)):\n    row = merged_data.iloc[i]\n    idx = merged_data.index[i]\n    # Buy condition\n    if not in_position or row['VI_Cross_Up'] or row['5_day_avg_sentiment_norm']&gt;0:\n        merged_data.at[idx, 'Buy_Signal'] = True\n        merged_data.at[idx, 'Position'] = 1\n        in_position = True\n        peak_price = row['Close_AAPL']\n\n        # Entry Type: aggressive if ATR &lt; 3%, else conservative\n        if row['atr_pct'] &lt; 0.03:\n            merged_data.at[idx, 'Entry_Type'] = 'aggressive'\n        else:\n            merged_data.at[idx, 'Entry_Type'] = 'conservative'\n\n    # While in position, check for trailing stop or VI cross down\n    elif in_position:\n        current_price = row['Close_AAPL']\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03 or row['VI_Cross_Down']:\n            merged_data.at[idx, 'Sell_Signal'] = True\n            merged_data.at[idx, 'Position'] = 0\n            in_position = False\n        else:\n            merged_data.at[idx, 'Position'] = 1\n\n# Show result counts\nprint(\"Buy signals:\", merged_data['Buy_Signal'].sum())\nprint(\"Sell signals:\", merged_data['Sell_Signal'].sum())\nprint(\"Aggressive entries:\", (merged_data['Entry_Type'] == 'aggressive').sum())\nprint(\"Conservative entries:\", (merged_data['Entry_Type'] == 'conservative').sum())\n\n\nBuy signals: 28\nSell signals: 1\nAggressive entries: 23\nConservative entries: 5\n\n\n\n\nCode\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\n# Plot merged_data closing price\nfig.add_trace(go.Scatter(\n    x=merged_data.index, \n    y=merged_data['Close_AAPL'], \n    mode='lines', \n    name='merged_data Price', \n    line=dict(color='blue')\n))\n\n# Aggressive buys\nfig.add_trace(go.Scatter(\n    x=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'aggressive')].index,\n    y=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'aggressive')]['Close_AAPL'],\n    mode='markers',\n    name='Buy (Aggressive)',\n    marker=dict(symbol='triangle-up', color='limegreen', size=10)\n))\n\n# Conservative buys\nfig.add_trace(go.Scatter(\n    x=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'conservative')].index,\n    y=merged_data[(merged_data['Buy_Signal']) & (merged_data['Entry_Type'] == 'conservative')]['Close_AAPL'],\n    mode='markers',\n    name='Buy (Conservative)',\n    marker=dict(symbol='triangle-up', color='green', size=10)\n))\n\n# Sells\nfig.add_trace(go.Scatter(\n    x=merged_data[merged_data['Sell_Signal']].index,\n    y=merged_data[merged_data['Sell_Signal']]['Close_AAPL'],\n    mode='markers',\n    name='Sell Signal',\n    marker=dict(symbol='triangle-down', color='red', size=10)\n))\n\nfig.update_layout(\n    title='merged_data Buy/Sell Signals Over Time',\n    xaxis_title='Date',\n    yaxis_title='Price (USD)',\n    template='plotly_white',\n    height=600\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nimport plotly.graph_objects as go\n\n# Ensure 'Date' is datetime and set as index if needed\nmerged_data['Date'] = pd.to_datetime(merged_data['Date'])\n\nfig = go.Figure()\n\n# Plot 5-day Avg Sentiment\nfig.add_trace(go.Scatter(\n    x=merged_data['Date'],\n    y=merged_data['5_day_avg_sentiment_norm'],\n    mode='lines+markers',\n    name='5-Day Avg Sentiment',\n    line=dict(color='blue')\n))\n\n# Plot ATR %\nfig.add_trace(go.Scatter(\n    x=merged_data['Date'],\n    y=merged_data['atr_pct'],\n    mode='lines+markers',\n    name='ATR %',\n    yaxis='y2',\n    line=dict(color='orange')\n))\n\n# Optional: Highlight Buy Signal Dates (even though there are none now)\nfig.add_trace(go.Scatter(\n    x=merged_data.loc[merged_data['Buy_Signal'], 'Date'],\n    y=merged_data.loc[merged_data['Buy_Signal'], '5_day_avg_sentiment_norm'],\n    mode='markers',\n    marker=dict(color='green', size=10, symbol='star'),\n    name='Buy Signal'\n))\n\n# Add dual axis layout\nfig.update_layout(\n    title=\"5-Day Sentiment vs ATR % (with Buy Signals)\",\n    xaxis_title='Date',\n    yaxis=dict(title='5-Day Avg Sentiment'),\n    yaxis2=dict(title='ATR %', overlaying='y', side='right'),\n    legend=dict(x=0.01, y=0.99),\n    height=500\n)\n\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=merged_data.index, y=merged_data['Close_AAPL'], mode='lines', name='merged_data Price'))\n\n# Buy markers\nfig.add_trace(go.Scatter(\n    x=merged_data[merged_data['Buy_Signal']].index,\n    y=merged_data[merged_data['Buy_Signal']]['Close_AAPL'],\n    mode='markers',\n    marker=dict(symbol='triangle-up', size=10, color='green'),\n    name='Buy Signal'\n))\n\n# Sell markers\nfig.add_trace(go.Scatter(\n    x=merged_data[merged_data['Sell_Signal']].index,\n    y=merged_data[merged_data['Sell_Signal']]['Close_AAPL'],\n    mode='markers',\n    marker=dict(symbol='triangle-down', size=10, color='red'),\n    name='Sell Signal'\n))\n\nfig.update_layout(title='XLY Buy & Sell Signals', template='plotly_white')\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\ncapital = 100000\nin_position = False\nentry_price = 0\nposition_value = 0\ncash = capital\nreturns = []\n\nfor i in range(len(merged_data)):\n    row = merged_data.iloc[i]\n    \n    # Buy\n    if row['Buy_Signal'] and not in_position:\n        position_size = row['position_size']\n        position_value = cash * position_size\n        entry_price = row['Close_AAPL']\n        shares_bought = position_value / entry_price\n        cash -= position_value\n        in_position = True\n        \n    # Sell\n    elif row['Sell_Signal'] and in_position:\n        exit_price = row['Close_AAPL']\n        proceeds = shares_bought * exit_price\n        profit = proceeds - position_value\n        cash += proceeds\n        returns.append(profit)\n        in_position = False\n        position_value = 0\n        entry_price = 0\n\n# Final capital\nfinal_value = cash + (shares_bought * row['Close_AAPL'] if in_position else 0)\ntotal_return = final_value - capital\n\nprint(f\"Final Capital: ${final_value:.2f}\")\nprint(f\"Total Return: ${total_return:.2f}\")\nprint(f\"Total Trades: {len(returns)}\")\nprint(f\"Average Profit per Trade: ${np.mean(returns):.2f}\")\n\n\nFinal Capital: $100057.01\nTotal Return: $57.01\nTotal Trades: 1\nAverage Profit per Trade: $-24.62\n\n\n\n\nCode\nimport vectorbt as vbt\n\n# Make sure index is datetime and 'Close_TSLA' exists\nprice = merged_data['Close_AAPL']\n\n# Generate entries and exits from your signals\nentries = merged_data['Buy_Signal']\nexits = merged_data['Sell_Signal']\n\n# Create portfolio\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    size=np.nan,  # Let it auto-calculate position size if fixed capital\n    init_cash=100_000,\n    fees=0.001,  # 0.1% per trade\n    slippage=0.0005  # Optional\n)\n\n# Plot portfolio value\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\nStart                              0.000000\nEnd                               30.000000\nPeriod                            31.000000\nStart Value                   100000.000000\nEnd Value                     100000.000000\nTotal Return [%]                   0.000000\nBenchmark Return [%]               1.780762\nMax Gross Exposure [%]             0.000000\nTotal Fees Paid                    0.000000\nMax Drawdown [%]                        NaN\nMax Drawdown Duration                   NaN\nTotal Trades                       0.000000\nTotal Closed Trades                0.000000\nTotal Open Trades                  0.000000\nOpen Trade PnL                     0.000000\nWin Rate [%]                            NaN\nBest Trade [%]                          NaN\nWorst Trade [%]                         NaN\nAvg Winning Trade [%]                   NaN\nAvg Losing Trade [%]                    NaN\nAvg Winning Trade Duration              NaN\nAvg Losing Trade Duration               NaN\nProfit Factor                           NaN\nExpectancy                              NaN\ndtype: float64\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nappl_ = merged_data.dropna(subset=['Close_AAPL'])\nentries = merged_data['Buy_Signal'].astype(bool)\nexits = merged_data['Sell_Signal'].astype(bool)\n\nprice = merged_data['Close_AAPL']\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    init_cash=100_000,\n    fees=0.001\n)\n\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\n\nStart                              0.000000\nEnd                               30.000000\nPeriod                            31.000000\nStart Value                   100000.000000\nEnd Value                     105185.963339\nTotal Return [%]                   5.185963\nBenchmark Return [%]               1.780762\nMax Gross Exposure [%]           100.000000\nTotal Fees Paid                  294.586321\nMax Drawdown [%]                   4.900568\nMax Drawdown Duration             10.000000\nTotal Trades                       2.000000\nTotal Closed Trades                1.000000\nTotal Open Trades                  1.000000\nOpen Trade PnL                  7842.950122\nWin Rate [%]                       0.000000\nBest Trade [%]                    -2.659644\nWorst Trade [%]                   -2.659644\nAvg Winning Trade [%]                   NaN\nAvg Losing Trade [%]              -2.659644\nAvg Winning Trade Duration              NaN\nAvg Losing Trade Duration          2.000000\nProfit Factor                      0.000000\nExpectancy                     -2656.986783\ndtype: float64\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\nWithout Sentiment\n\n\nCode\n# WITHOUT sentiment\nappl_copy = appl.copy()\nappl_copy['atr_pct'] = appl_copy['ATR_10'] / appl_copy['Close_AAPL']\n\n# Create Buy Signal (assuming VI_Cross_Up is defined elsewhere)\nappl_copy['Buy_Signal'] = appl_copy['VI+_'] &gt; appl_copy['VI-_']  # Vortex crossover\n# + add any other buy conditions here...\n\n# Create Sell Signal (basic)\nappl_copy['Sell_Signal'] = appl_copy['VI-_'] &gt; appl_copy['VI+_']\n\n# Initialize position state\nappl_copy['Position'] = 0\npeak_price = 0\n\nfor i in range(1, len(appl_copy)):\n    if appl_copy['Buy_Signal'].iloc[i]:\n        appl_copy.at[appl_copy.index[i], 'Position'] = 1\n        peak_price = appl_copy['Close_AAPL'].iloc[i]\n    elif appl_copy['Position'].iloc[i - 1] == 1:\n        current_price = appl_copy['Close_AAPL'].iloc[i]\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03:\n            appl_copy.at[appl_copy.index[i], 'Sell_Signal'] = True  # trailing stop\n            appl_copy.at[appl_copy.index[i], 'Position'] = 0\n        else:\n            appl_copy.at[appl_copy.index[i], 'Position'] = 1\n\n\n\n\nCode\ncapital = 100000\nin_position = False\nentry_price = 0\nposition_value = 0\ncash = capital\nreturns = []\n\nfor i in range(len(appl_copy)):\n    row = appl_copy.iloc[i]\n    \n    # Buy\n    if row['Buy_Signal'] and not in_position:\n        position_size = row['position_size']\n        position_value = cash * position_size\n        entry_price = row['Close_AAPL']\n        shares_bought = position_value / entry_price\n        cash -= position_value\n        in_position = True\n        \n    # Sell\n    elif row['Sell_Signal'] and in_position:\n        exit_price = row['Close_AAPL']\n        proceeds = shares_bought * exit_price\n        profit = proceeds - position_value\n        cash += proceeds\n        returns.append(profit)\n        in_position = False\n        position_value = 0\n        entry_price = 0\n\n# Final capital\nfinal_value = cash + (shares_bought * row['Close_AAPL'] if in_position else 0)\ntotal_return = final_value - capital\n\nprint(f\"Final Capital: ${final_value:.2f}\")\nprint(f\"Total Return: ${total_return:.2f}\")\nprint(f\"Total Trades: {len(returns)}\")\nprint(f\"Average Profit per Trade: ${np.mean(returns):.2f}\")\n\n\nFinal Capital: $101607.34\nTotal Return: $1607.34\nTotal Trades: 66\nAverage Profit per Trade: $24.26\n\n\n\n\nCode\nimport vectorbt as vbt\n\nappl = appl_copy.dropna(subset=['Close_AAPL'])\nentries = appl_copy['Buy_Signal'].astype(bool)\nexits = appl_copy['Sell_Signal'].astype(bool)\n\nprice = appl_copy['Close_AAPL']\nportfolio = vbt.Portfolio.from_signals(\n    close=price,\n    entries=entries,\n    exits=exits,\n    init_cash=100_000,\n    fees=0.001\n)\n\nprint(portfolio.stats())\nportfolio.plot().show()\n\n\nStart                         2019-01-02 00:00:00\nEnd                           2025-03-04 00:00:00\nPeriod                                       1551\nStart Value                              100000.0\nEnd Value                           381936.663857\nTotal Return [%]                       281.936664\nBenchmark Return [%]                   526.354228\nMax Gross Exposure [%]                      100.0\nTotal Fees Paid                      35759.568798\nMax Drawdown [%]                        20.871703\nMax Drawdown Duration                       351.0\nTotal Trades                                   67\nTotal Closed Trades                            66\nTotal Open Trades                               1\nOpen Trade PnL                        4424.594853\nWin Rate [%]                            45.454545\nBest Trade [%]                          41.284317\nWorst Trade [%]                        -11.056921\nAvg Winning Trade [%]                    8.072835\nAvg Losing Trade [%]                    -2.459744\nAvg Winning Trade Duration              24.766667\nAvg Losing Trade Duration                6.222222\nProfit Factor                            2.113946\nExpectancy                            4204.728318\ndtype: object\n\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sharpe_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'calmar_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'omega_ratio' requires frequency to be set\n\n/opt/anaconda3/lib/python3.11/site-packages/vectorbt/generic/stats_builder.py:396: UserWarning:\n\nMetric 'sortino_ratio' requires frequency to be set\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\nBased on the results from applying the trading strategy to the Apple (AAPL) ticker, we can reasonably conclude that the strategy does work on peers like AAPL. The strategy delivered a total return of approximately 282% over the backtest period (2019–2025), compared to a benchmark return of about 526%, which indicates it captured a significant portion of the upward trend while actively managing trades. Although it underperformed the benchmark in absolute terms, this is typical of signal-driven strategies that trade in and out of the market. The profit factor of 2.11, expectancy of 4204, and a win rate of 45.5% suggest the strategy was profitable overall. Additionally, the drawdown was moderate (20.87%), reflecting a reasonable risk exposure relative to the potential reward.\nThe cumulative returns graph further supports this interpretation. The strategy closely follows the broader market trend, generating consistent gains and outperforming during certain periods. The trade PnL distribution shows a good number of winning trades with healthy profitability, and although there were losses, the downside was generally contained. Therefore, this peer comparison confirms that the strategy generalizes reasonably well beyond TSLA, making it a potentially viable approach for other high-liquidity technology stocks like AAPL.\n\n\nCode\n# Calculate ATR percentage\nappl['atr_pct'] = appl['ATR_10'] / appl['Close_AAPL']\nappl['Buy_Signal'] = appl['VI+_'] &gt; appl['VI-_']  # Vortex crossover\nappl['Sell_Signal'] = appl['VI-_'] &gt; appl['VI+_']\n\n# Initialize position state\nappl['Position'] = 0\nappl['Entry_Type'] = None\npeak_price = 0\n\nfor i in range(1, len(appl)):\n    if appl['Buy_Signal'].iloc[i]:\n        appl.at[appl.index[i], 'Position'] = 1\n        peak_price = appl['Close_AAPL'].iloc[i]\n    elif appl['Position'].iloc[i - 1] == 1:\n        current_price = appl['Close_AAPL'].iloc[i]\n        peak_price = max(peak_price, current_price)\n        drawdown = (peak_price - current_price) / peak_price\n\n        if drawdown &gt;= 0.03:\n            appl.at[appl.index[i], 'Sell_Signal'] = True  # trailing stop\n            appl.at[appl.index[i], 'Position'] = 0\n        else:\n            appl.at[appl.index[i], 'Position'] = 1\n\nprint(\"Buy signals:\", appl['Buy_Signal'].sum())\nprint(\"Sell signals:\", appl['Sell_Signal'].sum())\n\n\nBuy signals: 985\nSell signals: 552\n\n\n\n\nCode\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(x=appl.index, y=appl['Close_AAPL'], mode='lines', name='AAPL Price'))\n\n# Buy markers\nfig.add_trace(go.Scatter(\n    x=appl[appl['Buy_Signal']].index,\n    y=appl[appl['Buy_Signal']]['Close_AAPL'],\n    mode='markers',\n    marker=dict(symbol='triangle-up', size=10, color='green'),\n    name='Buy Signal'\n))\n\n# Sell markers\nfig.add_trace(go.Scatter(\n    x=appl[appl['Sell_Signal']].index,\n    y=appl[appl['Sell_Signal']]['Close_AAPL'],\n    mode='markers',\n    marker=dict(symbol='triangle-down', size=10, color='red'),\n    name='Sell Signal'\n))\n\nfig.update_layout(title='AAPL Buy & Sell Signals', template='plotly_white')\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  },
  {
    "objectID": "data_oracles_strategy.html#vi-plots",
    "href": "data_oracles_strategy.html#vi-plots",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "VI Plots",
    "text": "VI Plots\n\n\nCode\ntsla = yf.download('TSLA', start='2019-01-01', end='2025-03-05')\nxly = yf.download('XLY', start='2019-01-01', end='2025-03-05')\nspy = yf.download('SPY', start='2019-01-01', end='2025-03-05')\n\n\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n[*********************100%***********************]  1 of 1 completed\n\n\n\n\nCode\ndef calculate_vortex(df, value, n=14):\n    high = df[(\"High\", value)]\n    low = df[(\"Low\", value)]\n    close = df[(\"Close\", value)]\n\n    # Calculate VM+ and VM-\n    vm_plus = abs(high - low.shift(1))   # |Today's High - Yesterday's Low|\n    vm_minus = abs(low - high.shift(1))  # |Today's Low - Yesterday's High|\n\n    # Calculate True Range (TR)\n    tr = pd.concat([\n        high - low,\n        abs(high - close.shift(1)),\n        abs(low - close.shift(1))\n    ], axis=1).max(axis=1)\n\n    # Rolling sum for lookback period\n    sum_vm_plus = vm_plus.rolling(window=n).sum()\n    sum_vm_minus = vm_minus.rolling(window=n).sum()\n    sum_tr = tr.rolling(window=n).sum()\n\n    # Compute VI+ and VI-\n    vi_plus = sum_vm_plus / sum_tr\n    vi_minus = sum_vm_minus / sum_tr\n\n    return vi_plus, vi_minus\n\n\n\n\nCode\ntsla['VI+'], tsla['VI-'] = calculate_vortex(tsla, 'TSLA')\nxly['VI+'], xly['VI-'] = calculate_vortex(xly, 'XLY')\nspy['VI+'], spy['VI-'] = calculate_vortex(spy, 'SPY')\n\n\n\n\nCode\n\n# Flatten MultiIndex columns \ntsla.columns = [\n    '_'.join(col).strip() if isinstance(col, tuple) else col\n    for col in tsla.columns\n]\n\n# Calculate True Range\ntsla[\"prev_close\"] = tsla[\"Close_TSLA\"].shift(1)\ntsla[\"tr1\"] = tsla[\"High_TSLA\"] - tsla[\"Low_TSLA\"]\ntsla[\"tr2\"] = abs(tsla[\"High_TSLA\"] - tsla[\"prev_close\"])\ntsla[\"tr3\"] = abs(tsla[\"Low_TSLA\"] - tsla[\"prev_close\"])\n\ntsla[\"true_range\"] = tsla[[\"tr1\", \"tr2\", \"tr3\"]].max(axis=1)\n\n# 10-day ATR\ntsla[\"ATR_10\"] = tsla[\"true_range\"].rolling(window=10).mean()\n\n# ---- STEP 4: Calculate ATR as a percentage of closing price ----\ntsla[\"atr_pct\"] = tsla[\"ATR_10\"] / tsla[\"Close_TSLA\"]\n\n# allocating the capital\n\ndef position_size(row):\n    if row[\"atr_pct\"] &lt; 0.03:  # &lt; 3% volatility → low risk\n        return 0.01  # allocate 1% of capital\n    else:  # ≥ 3% volatility → high risk\n        return 0.005  # allocate 0.5% of capital\n\ntsla[\"position_size\"] = tsla.apply(position_size, axis=1)\n\n# ---- STEP 6: Optional - Capital allocation per trade ----\n#capital = 100000 # Example: $100K total portfolio\n#tsla[\"allocation_dollars\"] = tsla[\"position_size\"] * capital\n\n# ---- Preview ----\nprint(tsla[[\"Close_TSLA\", \"ATR_10\", \"atr_pct\", \"position_size\"]].tail(10))\n\n\n            Close_TSLA     ATR_10   atr_pct  position_size\nDate                                                      \n2025-02-19  360.559998  16.703000  0.046325          0.005\n2025-02-20  354.399994  16.464999  0.046459          0.005\n2025-02-21  337.799988  17.021997  0.050391          0.005\n2025-02-24  330.529999  16.770996  0.050740          0.005\n2025-02-25  302.799988  18.879996  0.062351          0.005\n2025-02-26  290.799988  18.412994  0.063318          0.005\n2025-02-27  281.950012  18.257996  0.064756          0.005\n2025-02-28  292.980011  18.067996  0.061670          0.005\n2025-03-03  284.649994  19.281998  0.067739          0.005\n2025-03-04  272.040009  20.654996  0.075926          0.005\n\n\n\n\nCode\nimport plotly.express as px\nfig = px.line(tsla, x=tsla.index, y=\"atr_pct\", title=\"ATR% Over Time\")\nfig.add_hline(y=0.03, line_dash=\"dot\", line_color=\"green\", annotation_text=\"Low Volatility Cutoff\")\nfig.show()\n\n\n/opt/anaconda3/lib/python3.11/site-packages/_plotly_utils/basevalidators.py:106: FutureWarning:\n\nThe behavior of DatetimeProperties.to_pydatetime is deprecated, in a future version this will return a Series containing python datetime objects instead of an ndarray. To retain the old behavior, call `np.array` on the result\n\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=tsla.index,\n    y=tsla[\"VI+_\"],\n    mode='lines',\n    name='VI+_',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=tsla.index,\n    y=tsla[\"VI-_\"],\n    mode='lines',\n    name='VI-_',\n    line=dict(color='orange')\n))\n\nfig.update_layout(\n    title=\"Vortex Indicator (VI+ and VI−) for TSLA\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Value\",\n    legend=dict(x=0, y=1.1, orientation=\"h\"),\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\ntsla_2025 = tsla.loc[\"2025\"]\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=tsla_2025.index,\n    y=tsla_2025[\"VI+_\"],\n    mode='lines',\n    name='VI+',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=tsla_2025.index,\n    y=tsla_2025[\"VI-_\"],\n    mode='lines',\n    name='VI-',\n    line=dict(color='orange')\n))\n\nfig.update_layout(\n    title=\"Vortex Indicator (VI+ and VI−) for TSLA - 2025\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Value\",\n    legend=dict(x=0, y=1.1, orientation=\"h\"),\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=spy.index,\n    y=spy[\"VI+\"],\n    mode='lines',\n    name='VI+',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=spy.index,\n    y=spy[\"VI-\"],\n    mode='lines',\n    name='VI-',\n    line=dict(color='orange')\n))\n\nfig.update_layout(\n    title=\"Vortex Indicator (VI+ and VI−) for SPY\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Value\",\n    legend=dict(x=0, y=1.1, orientation=\"h\"),\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nspy_2025 = spy.loc[\"2025\"]\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=spy_2025.index,\n    y=spy_2025[\"VI+\"],\n    mode='lines',\n    name='VI+',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=spy_2025.index,\n    y=spy_2025[\"VI-\"],\n    mode='lines',\n    name='VI-',\n    line=dict(color='orange')\n))\n\nfig.update_layout(\n    title=\"Vortex Indicator (VI+ and VI−) for SPY - 2025\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Value\",\n    legend=dict(x=0, y=1.1, orientation=\"h\"),\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=xly.index,\n    y=xly[\"VI+\"],\n    mode='lines',\n    name='VI+',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=xly.index,\n    y=xly[\"VI-\"],\n    mode='lines',\n    name='VI-',\n    line=dict(color='orange')\n))\n\nfig.update_layout(\n    title=\"Vortex Indicator (VI+ and VI−) for XLY\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Value\",\n    legend=dict(x=0, y=1.1, orientation=\"h\"),\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nxly_2025 = xly.loc[\"2025\"]\n\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=xly_2025.index,\n    y=xly_2025[\"VI+\"],\n    mode='lines',\n    name='VI+',\n    line=dict(color='blue')\n))\n\nfig.add_trace(go.Scatter(\n    x=xly_2025.index,\n    y=xly_2025[\"VI-\"],\n    mode='lines',\n    name='VI-',\n    line=dict(color='orange')\n))\n\nfig.update_layout(\n    title=\"Vortex Indicator (VI+ and VI−) for XLY - 2025\",\n    xaxis_title=\"Date\",\n    yaxis_title=\"Value\",\n    legend=dict(x=0, y=1.1, orientation=\"h\"),\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nfrom plotly.subplots import make_subplots\n\nfig = make_subplots(\n    rows=3, cols=1,\n    subplot_titles=(\"SPY - 2025\", \"XLY - 2025\", \"TSLA - 2025\")\n)\n\nfig.add_trace(go.Scatter(\n    x=spy_2025.index,\n    y=spy_2025[\"VI+\"],\n    name=\"VI+ (SPY)\",\n    line=dict(color='blue'),\n    showlegend=False\n), row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=spy_2025.index,\n    y=spy_2025[\"VI-\"],\n    name=\"VI- (SPY)\",\n    line=dict(color='orange'),\n    showlegend=False\n), row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=xly_2025.index,\n    y=xly_2025[\"VI+\"],\n    name=\"VI+ (XLY)\",\n    line=dict(color='blue'),\n    showlegend=False\n), row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=xly_2025.index,\n    y=xly_2025[\"VI-\"],\n    name=\"VI- (XLY)\",\n    line=dict(color='orange'),\n    showlegend=False\n), row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=tsla_2025.index,\n    y=tsla_2025[\"VI+_\"],\n    name=\"VI+ (TSLA)\",\n    line=dict(color='blue'),\n    showlegend=False\n), row=3, col=1)\n\nfig.add_trace(go.Scatter(\n    x=tsla_2025.index,\n    y=tsla_2025[\"VI-_\"],\n    name=\"VI- (TSLA)\",\n    line=dict(color='orange'),\n    showlegend=False\n), row=3, col=1)\n\nfig.update_layout(\n    height=500, width=1200,\n    title_text=\"Vortex Indicator (VI+ and VI−) - 2025 Comparison\",\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json\n\n\n\n\nCode\nfig = make_subplots(\n    rows=3, cols=1,\n    subplot_titles=(\"SPY Year To Year\", \"XLY Year To Year\", \"TSLA Year To Year\")\n)\n\nfig.add_trace(go.Scatter(\n    x=spy.index,\n    y=spy[\"VI+\"],\n    name=\"VI+ (SPY)\",\n    line=dict(color='blue'),\n    showlegend=False\n), row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=spy.index,\n    y=spy[\"VI-\"],\n    name=\"VI- (SPY)\",\n    line=dict(color='orange'),\n    showlegend=False\n), row=1, col=1)\n\nfig.add_trace(go.Scatter(\n    x=xly.index,\n    y=xly[\"VI+\"],\n    name=\"VI+ (XLY)\",\n    line=dict(color='blue'),\n    showlegend=False\n), row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=xly.index,\n    y=xly[\"VI-\"],\n    name=\"VI- (XLY)\",\n    line=dict(color='orange'),\n    showlegend=False\n), row=2, col=1)\n\nfig.add_trace(go.Scatter(\n    x=tsla.index,\n    y=tsla[\"VI+_\"],\n    name=\"VI+ (TSLA)\",\n    line=dict(color='blue'),\n    showlegend=False\n), row=3, col=1)\n\nfig.add_trace(go.Scatter(\n    x=tsla.index,\n    y=tsla[\"VI-_\"],\n    name=\"VI- (TSLA)\",\n    line=dict(color='orange'),\n    showlegend=False\n), row=3, col=1)\n\nfig.update_layout(\n    height=900, width=1200,\n    title_text=\"Vortex Indicator (VI+ and VI−) - Full Period Comparison\",\n    template=\"plotly_white\"\n)\n\nfig.show()\n\n\nUnable to display output for mime type(s): application/vnd.plotly.v1+json"
  },
  {
    "objectID": "data_oracles_strategy.html",
    "href": "data_oracles_strategy.html",
    "title": "Vortex–Sentiment Adaptive Volatility (VSAV) Strategy",
    "section": "",
    "text": "Code\nimport yfinance as yf  # For downloading financial data\nimport numpy as np      # For numerical operations\nimport pandas as pd     # For data manipulation\nimport requests # For downloading the API data\nimport numpy as np \nimport plotly.graph_objects as go\nimport plotly.express as px # Import the Plotly Express module for interactive visualization\nimport json\nimport vectorbt as vbt\nfrom plotly.subplots import make_subplots"
  }
]